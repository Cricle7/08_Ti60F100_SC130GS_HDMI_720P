// =============================================================================
// Generated by efx_ipmgr
// Version: 2023.2.307
// IP Version: 6.2
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2023 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

`define IP_UUID _4443cdd14915431b8db74095d4c71f59
`define IP_NAME_CONCAT(a,b) a``b
`define IP_MODULE_NAME(name) `IP_NAME_CONCAT(name,`IP_UUID)
module hbram (
output io_arw_ready,
input io_arw_valid,
input io_axi_clk,
input ram_clk_cal,
input ram_clk,
input rst,
input [31:0] io_arw_payload_addr,
input [7:0] io_arw_payload_id,
input [7:0] io_arw_payload_len,
input [2:0] io_arw_payload_size,
input [1:0] io_arw_payload_burst,
input [1:0] io_arw_payload_lock,
input io_arw_payload_write,
input [7:0] io_w_payload_id,
output io_w_ready,
input io_w_valid,
output io_b_valid,
input io_w_payload_last,
output [7:0] io_b_payload_id,
input io_b_ready,
output io_r_valid,
input io_r_ready,
output [7:0] io_r_payload_id,
output hbc_cal_pass,
output hbc_ck_n_LO,
output hbc_ck_n_HI,
output hbc_ck_p_LO,
output hbc_ck_p_HI,
output hbc_cs_n,
output hbc_rst_n,
output [4:0] hbc_cal_SHIFT_SEL,
output [2:0] hbc_cal_SHIFT,
output hbc_cal_SHIFT_ENA,
output io_r_payload_last,
output [1:0] io_r_payload_resp,
input [127:0] io_w_payload_data,
input [15:0] io_w_payload_strb,
output [127:0] io_r_payload_data,
output [15:0] hbc_dq_OE,
input [15:0] hbc_dq_IN_LO,
input [15:0] hbc_dq_IN_HI,
output [15:0] hbc_dq_OUT_LO,
output [15:0] hbc_dq_OUT_HI,
output [1:0] hbc_rwds_OE,
input [1:0] hbc_rwds_IN_LO,
input [1:0] hbc_rwds_IN_HI,
output [1:0] hbc_rwds_OUT_LO,
output [1:0] hbc_rwds_OUT_HI,
output [26:0] hbc_cal_debug_info,
input [2:0] dyn_pll_phase_sel,
input dyn_pll_phase_en
);
`IP_MODULE_NAME(hbram_top) #(
.RAM_DBW (16),
.RAM_ABW (25),
.CR0_DPD (1'b1),
.CR0_ILC (2),
.CR0_ODS (0),
.CR0_HBE (1'b1),
.CR0_WBL (0),
.CR0_FLE (1'b1),
.CR1_MCT (1'b1),
.CR1_PAR (0),
.CR1_HSE (1'b0),
.DDIN_MODE (1'b0),
.AXI_AWR_DEPTH (16),
.CAL_CLK_CH (4),
.CAL_MODE (2),
.TRTR (40000),
.TRH (200000),
.TVCS (150000000),
.TCSM (4000000),
.MHZ (250),
.CAL_RWDS_STEPS (8),
.CAL_DQ_STEPS (8),
.CAL_BYTES (250),
.AXI_IF (1'b1),
.AXI_DBW (128),
.AXI_SBW (16),
.AXI_R_DEPTH (256),
.AXI_W_DEPTH (256),
.DUAL_RAM (0),
.INDIVI_DUAL_CAL (0),
.CAL_CLK_CH_LO (4),
.CAL_CLK_CH_HI (8)
) u_hbram_top(
.io_arw_ready ( io_arw_ready ),
.io_arw_valid ( io_arw_valid ),
.io_axi_clk ( io_axi_clk ),
.ram_clk_cal ( ram_clk_cal ),
.ram_clk ( ram_clk ),
.rst ( rst ),
.io_arw_payload_addr ( io_arw_payload_addr ),
.io_arw_payload_id ( io_arw_payload_id ),
.io_arw_payload_len ( io_arw_payload_len ),
.io_arw_payload_size ( io_arw_payload_size ),
.io_arw_payload_burst ( io_arw_payload_burst ),
.io_arw_payload_lock ( io_arw_payload_lock ),
.io_arw_payload_write ( io_arw_payload_write ),
.io_w_payload_id ( io_w_payload_id ),
.io_w_ready ( io_w_ready ),
.io_w_valid ( io_w_valid ),
.io_b_valid ( io_b_valid ),
.io_w_payload_last ( io_w_payload_last ),
.io_b_payload_id ( io_b_payload_id ),
.io_b_ready ( io_b_ready ),
.io_r_valid ( io_r_valid ),
.io_r_ready ( io_r_ready ),
.io_r_payload_id ( io_r_payload_id ),
.hbc_cal_pass ( hbc_cal_pass ),
.hbc_ck_n_LO ( hbc_ck_n_LO ),
.hbc_ck_n_HI ( hbc_ck_n_HI ),
.hbc_ck_p_LO ( hbc_ck_p_LO ),
.hbc_ck_p_HI ( hbc_ck_p_HI ),
.hbc_cs_n ( hbc_cs_n ),
.hbc_rst_n ( hbc_rst_n ),
.hbc_cal_SHIFT_SEL ( hbc_cal_SHIFT_SEL ),
.hbc_cal_SHIFT ( hbc_cal_SHIFT ),
.hbc_cal_SHIFT_ENA ( hbc_cal_SHIFT_ENA ),
.io_r_payload_last ( io_r_payload_last ),
.io_r_payload_resp ( io_r_payload_resp ),
.io_w_payload_data ( io_w_payload_data ),
.io_w_payload_strb ( io_w_payload_strb ),
.io_r_payload_data ( io_r_payload_data ),
.hbc_dq_OE ( hbc_dq_OE ),
.hbc_dq_IN_LO ( hbc_dq_IN_LO ),
.hbc_dq_IN_HI ( hbc_dq_IN_HI ),
.hbc_dq_OUT_LO ( hbc_dq_OUT_LO ),
.hbc_dq_OUT_HI ( hbc_dq_OUT_HI ),
.hbc_rwds_OE ( hbc_rwds_OE ),
.hbc_rwds_IN_LO ( hbc_rwds_IN_LO ),
.hbc_rwds_IN_HI ( hbc_rwds_IN_HI ),
.hbc_rwds_OUT_LO ( hbc_rwds_OUT_LO ),
.hbc_rwds_OUT_HI ( hbc_rwds_OUT_HI ),
.hbc_cal_debug_info ( hbc_cal_debug_info ),
.dyn_pll_phase_sel ( dyn_pll_phase_sel ),
.dyn_pll_phase_en ( dyn_pll_phase_en )
);

endmodule

module `IP_MODULE_NAME(hbram_top) #(
    parameter       MHZ            = 200,
    parameter       RAM_DBW        = 16,
    parameter       RAM_ABW        = 32,
    parameter [0:0] CR0_DPD        = 1'b1,
    parameter [2:0] CR0_ODS        = 3'b000,
    parameter [3:0] CR0_ILC        = 4'b0010,
    parameter [0:0] CR0_FLE        = 1'b1,
    parameter [0:0] CR0_HBE        = 1'b1,
    parameter [1:0] CR0_WBL        = 2'b11,
    parameter [0:0] CR1_MCT        = 1'b1,
    parameter [0:0] CR1_HSE        = 1'b1,
    parameter [2:0] CR1_PAR        = 3'b000,
    parameter       AXI_IF         = 1,
    parameter       AXI_DBW        = 64,
    parameter       AXI_SBW        = AXI_DBW/8,
    parameter       AXI_AWR_DEPTH  = 16,
    parameter       AXI_W_DEPTH    = 256,
    parameter       AXI_R_DEPTH    = 256,
    parameter       DDIN_MODE      = "",
    parameter [4:0] CAL_CLK_CH     = 5'b00001,
    parameter [4:0] CAL_CLK_CH_LO  = 5'b00001,
    parameter [4:0] CAL_CLK_CH_HI  = 5'b00010,
    parameter       CAL_MODE       = 2,
    parameter       CAL_DQ_STEPS   = 8,
    parameter       CAL_RWDS_STEPS = 8,
    parameter       CAL_BYTES      = 'h100,
    parameter       TCSM           = 4000000,
    parameter       TVCS           = 150000000,
    parameter       TRH            = 200000,
    parameter       TRTR           = 40000,
    parameter       PLL_MANUAL     = 0,
    parameter		DUAL_RAM 	   = 0,
    parameter 		INDIVI_DUAL_CAL	   = 0,
    parameter [15:0] CFG_CR1 = {9'h1ff, CR1_MCT, CR1_HSE, CR1_PAR, 2'b01},
	parameter [15:0] CFG_CR0 = {CR0_DPD, CR0_ODS, 4'b1111, CR0_ILC, CR0_FLE, CR0_HBE, CR0_WBL}
) (
    input  wire                 rst,
    input  wire                 ram_clk,
    input  wire                 ram_clk_cal,
    input  wire                 ram_clk_cal_2,
    input  wire                 io_axi_clk,
    input  wire                 io_arw_valid,
    input  wire [31:0]          io_arw_payload_addr,
    input  wire [7:0]           io_arw_payload_id,
    input  wire [7:0]           io_arw_payload_len,
    input  wire [2:0]           io_arw_payload_size,
    input  wire [1:0]           io_arw_payload_burst,
    input  wire [1:0]           io_arw_payload_lock,
    input  wire                 io_arw_payload_write,
    output wire                 io_arw_ready,
    input  wire [7:0]           io_w_payload_id,
    input  wire                 io_w_valid,
    input  wire [AXI_DBW-1:0]   io_w_payload_data,
    input  wire [AXI_SBW-1:0]   io_w_payload_strb,
    input  wire                 io_w_payload_last,
    output wire                 io_w_ready,
    input  wire                 io_b_ready,
    output wire                 io_b_valid,
    output wire [7:0]           io_b_payload_id,
    input  wire                 io_r_ready,
    output wire                 io_r_valid,
    output wire [AXI_DBW-1:0]   io_r_payload_data,
    output wire [7:0]           io_r_payload_id,
    output wire [1:0]           io_r_payload_resp,
    output wire                 io_r_payload_last,
    input  wire                 native_clk,
    input  wire                 native_ram_rdwr,
    input  wire                 native_ram_en,
    input  wire [10:0]          native_ram_burst_len,
    input  wire [31:0]          native_ram_address,
    input  wire [AXI_DBW-1:0]   native_wr_data,
    input  wire [AXI_SBW-1:0]   native_wr_datamask,
    input  wire                 native_wr_en,
    output wire                 native_wr_buf_ready,
    output wire [AXI_DBW-1:0]   native_rd_data,
    output wire                 native_rd_valid,
    output wire                 native_ctrl_idle,
    input  wire                 dyn_pll_phase_en,
    input  wire [2:0]           dyn_pll_phase_sel,
    output wire                 hbc_cal_SHIFT_ENA,
    output wire [2:0]           hbc_cal_SHIFT,
    output wire [4:0]           hbc_cal_SHIFT_SEL,
    output wire [2:0]           hbc_cal_SHIFT_HI,
    output wire [2:0]           hbc_cal_SHIFT_LO,
    output wire [26:0]          hbc_cal_debug_info,
    output wire                 hbc_rst_n,
    output wire                 hbc_cs_n,
    output wire                 hbc_ck_p_HI,
    output wire                 hbc_ck_p_LO,
    output wire                 hbc_ck_n_HI,
    output wire                 hbc_ck_n_LO,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_HI,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_LO,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_HI,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_LO,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OE,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_HI,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_LO,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_HI,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_LO,
    output wire [RAM_DBW-1:0]   hbc_dq_OE,
    output wire                 hbc_rst_n_2,
    output wire                 hbc_cs_n_2,
    output wire                 hbc_ck_p_HI_2,
    output wire                 hbc_ck_p_LO_2,
    output wire                 hbc_ck_n_HI_2,
    output wire                 hbc_ck_n_LO_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_HI_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_LO_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_HI_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_LO_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_LO_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_HI_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OE_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_HI_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_LO_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OE_2,
    output wire                 hbc_cal_pass
);


// IP Decryptor begin

//##START PROTECT##
wire user_clk;
generate
    if (AXI_IF) begin
        assign user_clk = io_axi_clk;
    end
    else begin
        assign user_clk = native_clk;
    end
endgenerate
localparam DQIN_MODE = DDIN_MODE ? "NORMAL" : "RESYNC";
localparam TCYC = (MHZ < 100) ? 10000 : 1000000/MHZ;
generate
if (CAL_MODE == 1)
begin: soft_cal_block
`IP_MODULE_NAME(hbram_cal_axi_top) #(
    .RAM_DBW        (RAM_DBW),
    .RAM_ABW        (RAM_ABW),
    .CFG_CR0        (CFG_CR0),
    .CR0_ILC		(CR0_ILC),
    .CFG_CR1        (CFG_CR1),
    .AXI_IF         (AXI_IF),
    .AXI_DBW        (AXI_DBW),
    .AXI_AWR_DEPTH  (AXI_AWR_DEPTH),
    .AXI_W_DEPTH    (AXI_W_DEPTH),
    .AXI_R_DEPTH    (AXI_R_DEPTH),
    .DQIN_MODE      (DQIN_MODE),
    .CAL_MODE       (CAL_MODE),
    .CAL_DQ_STEPS   (CAL_DQ_STEPS),
    .CAL_RWDS_STEPS (CAL_RWDS_STEPS),
    .TCYC           (TCYC),
    .TCSM           (TCSM),
    .TVCS           (TVCS),
    .TRH            (TRH),
    .TRTR           (TRTR),
    .CAL_BYTES      (CAL_BYTES),
    .DUAL_RAM		(DUAL_RAM),
    .INDIVI_DUAL_CAL		(INDIVI_DUAL_CAL)
) hbram_cal_axi_top_inst (
    .rst                  (rst),
    .ram_clk              (ram_clk),
    .io_axi_clk           (user_clk),
    .io_arw_valid         (io_arw_valid),
    .io_arw_ready         (io_arw_ready),
    .io_arw_payload_addr  (io_arw_payload_addr),
    .io_arw_payload_id    (io_arw_payload_id),
    .io_arw_payload_len   (io_arw_payload_len),
    .io_arw_payload_size  (io_arw_payload_size),
    .io_arw_payload_burst (io_arw_payload_burst),
    .io_arw_payload_lock  (io_arw_payload_lock),
    .io_arw_payload_write (io_arw_payload_write),
    .io_w_payload_id      (io_w_payload_id),
    .io_w_valid           (io_w_valid),
    .io_w_ready           (io_w_ready),
    .io_w_payload_data    (io_w_payload_data),
    .io_w_payload_strb    (io_w_payload_strb),
    .io_w_payload_last    (io_w_payload_last),
    .io_b_valid           (io_b_valid),
    .io_b_ready           (io_b_ready),
    .io_b_payload_id      (io_b_payload_id),
    .io_r_valid           (io_r_valid),
    .io_r_ready           (io_r_ready),
    .io_r_payload_data    (io_r_payload_data),
    .io_r_payload_id      (io_r_payload_id),
    .io_r_payload_resp    (io_r_payload_resp),
    .io_r_payload_last    (io_r_payload_last),
    .native_ram_rdwr      (native_ram_rdwr),
    .native_ram_en        (native_ram_en),
    .native_wr_data       (native_wr_data),
    .native_wr_burst_len  (native_ram_burst_len),
    .native_wr_datamask   (native_wr_datamask),
    .native_wr_address    (native_ram_address),
    .native_wr_en         (native_wr_en),
    .native_wr_buf_ready  (native_wr_buf_ready),
    .native_rd_data       (native_rd_data),
    .native_rd_valid      (native_rd_valid),
    .native_ctrl_idle     (native_ctrl_idle),
    .hbc_cal_SHIFT_ENA    (),
    .hbc_cal_SHIFT_SEL    (),
    .hbc_cal_SHIFT        (),
    .hbc_cal_pass         (hbc_cal_pass),
    .hbc_cal_debug_info   (hbc_cal_debug_info),
    .hbc_rst_n            (hbc_rst_n),
    .hbc_cs_n             (hbc_cs_n),
    .hbc_ck_p_HI          (hbc_ck_p_HI),
    .hbc_ck_p_LO          (hbc_ck_p_LO),
    .hbc_ck_n_HI          (hbc_ck_n_HI),
    .hbc_ck_n_LO          (hbc_ck_n_LO),
    .hbc_rwds_OUT_HI      (hbc_rwds_OUT_HI),
    .hbc_rwds_OUT_LO      (hbc_rwds_OUT_LO),
    .hbc_rwds_IN_HI       (hbc_rwds_IN_HI),
    .hbc_rwds_IN_LO       (),
    .hbc_rwds_OE          (hbc_rwds_OE),
    .hbc_dq_OUT_HI        (hbc_dq_OUT_HI),
    .hbc_dq_OUT_LO        (hbc_dq_OUT_LO),
    .hbc_dq_IN_HI         (hbc_dq_IN_HI),
    .hbc_dq_IN_LO         (),
    .hbc_dq_OE            (hbc_dq_OE),
    .hbc_rst_n_2           (hbc_rst_n_2),
    .hbc_cs_n_2            (hbc_cs_n_2),
	.hbc_ck_p_HI_2         (hbc_ck_p_HI_2),
	.hbc_ck_p_LO_2         (hbc_ck_p_LO_2),
	.hbc_ck_n_HI_2         (hbc_ck_n_HI_2),
	.hbc_ck_n_LO_2         (hbc_ck_n_LO_2),
	.hbc_rwds_OUT_HI_2     (hbc_rwds_OUT_HI_2),
	.hbc_rwds_OUT_LO_2     (hbc_rwds_OUT_LO_2),
	.hbc_rwds_IN_HI_2      (hbc_rwds_IN_HI_2),
	.hbc_rwds_IN_LO_2      (hbc_rwds_IN_LO_2),
	.hbc_rwds_OE_2         (hbc_rwds_OE_2),
	.hbc_dq_OUT_HI_2       (hbc_dq_OUT_HI_2),
	.hbc_dq_OUT_LO_2       (hbc_dq_OUT_LO_2),
	.hbc_dq_IN_HI_2        (hbc_dq_IN_HI_2),
	.hbc_dq_IN_LO_2        (hbc_dq_IN_LO_2),
	.hbc_dq_OE_2           (hbc_dq_OE_2)
);
end
else begin: hard_cal_block
`IP_MODULE_NAME(hbram_cal_axi_top) #(
    .RAM_DBW        (RAM_DBW),
    .RAM_ABW        (RAM_ABW),
    .CFG_CR0        (CFG_CR0),
    .CR0_ILC		(CR0_ILC),
    .CFG_CR1        (CFG_CR1),
    .AXI_IF         (AXI_IF),
    .AXI_DBW        (AXI_DBW),
    .AXI_AWR_DEPTH  (AXI_AWR_DEPTH),
    .AXI_W_DEPTH    (AXI_W_DEPTH),
    .AXI_R_DEPTH    (AXI_R_DEPTH),
    .DQIN_MODE      (DQIN_MODE),
    .CAL_CLK_CH     (CAL_CLK_CH),
    .CAL_CLK_CH_HI  (CAL_CLK_CH_HI),
    .CAL_CLK_CH_LO  (CAL_CLK_CH_LO),
    .CAL_MODE       (CAL_MODE),
    .CAL_DQ_STEPS   (CAL_DQ_STEPS),
    .CAL_RWDS_STEPS (CAL_RWDS_STEPS),
    .TCYC           (TCYC),
    .TCSM           (TCSM),
    .TVCS           (TVCS),
    .TRH            (TRH),
    .TRTR           (TRTR),
    .PLL_MANUAL     (PLL_MANUAL),
    .CAL_BYTES      (CAL_BYTES),
    .DUAL_RAM 		(DUAL_RAM),
    .INDIVI_DUAL_CAL		(INDIVI_DUAL_CAL)
) hbram_cal_axi_top_inst (
    .rst                  (rst),
    .ram_clk              (ram_clk),
    .ram_clk_cal          (ram_clk_cal),
    .ram_clk_cal_2		  (ram_clk_cal_2),
    .io_axi_clk           (user_clk),
    .io_arw_valid         (io_arw_valid),
    .io_arw_ready         (io_arw_ready),
    .io_arw_payload_addr  (io_arw_payload_addr),
    .io_arw_payload_id    (io_arw_payload_id),
    .io_arw_payload_len   (io_arw_payload_len),
    .io_arw_payload_size  (io_arw_payload_size),
    .io_arw_payload_burst (io_arw_payload_burst),
    .io_arw_payload_lock  (io_arw_payload_lock),
    .io_arw_payload_write (io_arw_payload_write),
    .io_w_payload_id      (io_w_payload_id),
    .io_w_valid           (io_w_valid),
    .io_w_ready           (io_w_ready),
    .io_w_payload_data    (io_w_payload_data),
    .io_w_payload_strb    (io_w_payload_strb),
    .io_w_payload_last    (io_w_payload_last),
    .io_b_valid           (io_b_valid),
    .io_b_ready           (io_b_ready),
    .io_b_payload_id      (io_b_payload_id),
    .io_r_valid           (io_r_valid),
    .io_r_ready           (io_r_ready),
    .io_r_payload_data    (io_r_payload_data),
    .io_r_payload_id      (io_r_payload_id),
    .io_r_payload_resp    (io_r_payload_resp),
    .io_r_payload_last    (io_r_payload_last),
    .native_ram_rdwr      (native_ram_rdwr),
    .native_ram_en        (native_ram_en),
    .native_wr_data       (native_wr_data),
    .native_wr_burst_len  (native_ram_burst_len),
    .native_wr_datamask   (native_wr_datamask),
    .native_wr_address    (native_ram_address),
    .native_wr_en         (native_wr_en),
    .native_wr_buf_ready  (native_wr_buf_ready),
    .native_rd_data       (native_rd_data),
    .native_rd_valid      (native_rd_valid),
    .native_ctrl_idle     (native_ctrl_idle),
    .dyn_pll_phase_en     (dyn_pll_phase_en),
    .dyn_pll_phase_sel    (dyn_pll_phase_sel),
    .hbc_cal_SHIFT_ENA    (hbc_cal_SHIFT_ENA),
    .hbc_cal_SHIFT_SEL    (hbc_cal_SHIFT_SEL),
    .hbc_cal_SHIFT        (hbc_cal_SHIFT),
    .hbc_cal_SHIFT_HI     (hbc_cal_SHIFT_HI),
    .hbc_cal_SHIFT_LO     (hbc_cal_SHIFT_LO),
    .hbc_cal_pass         (hbc_cal_pass),
    .hbc_cal_debug_info   (hbc_cal_debug_info),
    .hbc_rst_n            (hbc_rst_n),
    .hbc_cs_n             (hbc_cs_n),
    .hbc_ck_p_HI          (hbc_ck_p_HI),
    .hbc_ck_p_LO          (hbc_ck_p_LO),
    .hbc_ck_n_HI          (hbc_ck_n_HI),
    .hbc_ck_n_LO          (hbc_ck_n_LO),
    .hbc_rwds_OUT_HI      (hbc_rwds_OUT_HI),
    .hbc_rwds_OUT_LO      (hbc_rwds_OUT_LO),
    .hbc_rwds_IN_HI       (hbc_rwds_IN_HI),
    .hbc_rwds_IN_LO       (hbc_rwds_IN_LO),
    .hbc_rwds_OE          (hbc_rwds_OE),
    .hbc_dq_OUT_HI        (hbc_dq_OUT_HI),
    .hbc_dq_OUT_LO        (hbc_dq_OUT_LO),
    .hbc_dq_IN_HI         (hbc_dq_IN_HI),
    .hbc_dq_IN_LO         (hbc_dq_IN_LO),
    .hbc_dq_OE            (hbc_dq_OE),
    .hbc_rst_n_2           (hbc_rst_n_2),
    .hbc_cs_n_2            (hbc_cs_n_2),
	.hbc_ck_p_HI_2         (hbc_ck_p_HI_2),
	.hbc_ck_p_LO_2         (hbc_ck_p_LO_2),
	.hbc_ck_n_HI_2         (hbc_ck_n_HI_2),
	.hbc_ck_n_LO_2         (hbc_ck_n_LO_2),
	.hbc_rwds_OUT_HI_2     (hbc_rwds_OUT_HI_2),
	.hbc_rwds_OUT_LO_2     (hbc_rwds_OUT_LO_2),
	.hbc_rwds_IN_HI_2      (hbc_rwds_IN_HI_2),
	.hbc_rwds_IN_LO_2      (hbc_rwds_IN_LO_2),
	.hbc_rwds_OE_2         (hbc_rwds_OE_2),
	.hbc_dq_OUT_HI_2       (hbc_dq_OUT_HI_2),
	.hbc_dq_OUT_LO_2       (hbc_dq_OUT_LO_2),
	.hbc_dq_IN_HI_2        (hbc_dq_IN_HI_2),
	.hbc_dq_IN_LO_2        (hbc_dq_IN_LO_2),
	.hbc_dq_OE_2           (hbc_dq_OE_2)
);
end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end



////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   pipe_reg.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Parallel Pipelining Shift Register
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_datasync) #(
    parameter STAGE = 32,
    parameter WIDTH = 4
) (
 input  wire             clk_i,
 input  wire [WIDTH-1:0] d_i,
 output wire [WIDTH-1:0] d_o
);

(* async_reg = "true" *) reg [WIDTH-1:0] pipe_reg [STAGE-1:0];
integer i;

always @(posedge clk_i) begin
  for (i=STAGE-1; i>0; i = i - 1) begin
    pipe_reg[i] <= pipe_reg[i-1];
  end
  pipe_reg[0] <= d_i;
end
assign d_o = pipe_reg[STAGE-1];
   

endmodule

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   gray2bin.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Gray to Binary Encoding Convertor
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns/1ps

module `IP_MODULE_NAME(efx_fifo_gray2bin)
#(parameter WIDTH=5)
(// outputs
 output wire [WIDTH-1:0] bin_o,
 // input
 input [WIDTH-1:0] gray_i);

//---------------------------------------------------------------------
// Recursive Module
// Description: reduction xor
generate
   if (WIDTH > 1) begin
      wire [1:0] bin_1;
      assign bin_1 = {gray_i[WIDTH-1], gray_i[WIDTH-1]^gray_i[WIDTH-2]};
      if (WIDTH == 2) begin
	 assign bin_o = bin_1;
      end
      else begin
	 assign bin_o[WIDTH-1] = bin_1[1];
	 `IP_MODULE_NAME(efx_fifo_gray2bin) #(.WIDTH(WIDTH-1)) u_gray2bin (.bin_o(bin_o[WIDTH-2:0]), .gray_i({bin_1[0], gray_i[WIDTH-3:0]}));
      end
   end
   else /* if (WIDTH == 1) */
     assign bin_o = gray_i;
endgenerate
   
endmodule 

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_ram) #(
    parameter FAMILY        = "TRION",
    parameter MODE          = "STANDARD",
    parameter WR_DEPTH      = 512,
    parameter RD_DEPTH      = 512,
    parameter WDATA_WIDTH   = 8,
    parameter RDATA_WIDTH   = 8,
    parameter WADDR_WIDTH   = 9,
    parameter RADDR_WIDTH   = 9,
    parameter OUTPUT_REG    = 1,
    parameter RAM_MUX_RATIO = 4,
    parameter ENDIANESS 	= 0 //0: Big endian (default)   1: Little endian 
) (
    input  wire                     wclk,
    input  wire                     rclk,
    input  wire                     we,
    input  wire                     re,
    input  wire [(WDATA_WIDTH-1):0] wdata,
    input  wire [(WADDR_WIDTH-1):0] waddr,
    input  wire [(RADDR_WIDTH-1):0] raddr,
    output wire [(RDATA_WIDTH-1):0] rdata
);

localparam MEM_DEPTH         = (WR_DEPTH > RD_DEPTH) ? WR_DEPTH : RD_DEPTH;
localparam MEM_DATA_WIDTH    = (WDATA_WIDTH > RDATA_WIDTH) ? RDATA_WIDTH : WDATA_WIDTH;   
localparam LSB_WIDTH         = (WADDR_WIDTH > RADDR_WIDTH) ? (WADDR_WIDTH - RADDR_WIDTH) : (RADDR_WIDTH - WADDR_WIDTH);
localparam RDATA_WDATA_RATIO = (RDATA_WIDTH <= WDATA_WIDTH/32) ? "ONE_THIRTYTWO" :
                               (RDATA_WIDTH <= WDATA_WIDTH/16) ? "ONE_SIXTEENTH" :
                               (RDATA_WIDTH <= WDATA_WIDTH/8)  ? "ONE_EIGHTH"    :
                               (RDATA_WIDTH <= WDATA_WIDTH/4)  ? "ONE_FOURTH"    :
                               (RDATA_WIDTH <= WDATA_WIDTH/2)  ? "ONE_HALF"      :
                               (RDATA_WIDTH <= WDATA_WIDTH)    ? "ONE"           :
                               (RDATA_WIDTH <= WDATA_WIDTH*2)  ? "TWO_TIMES"     :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "FOUR_TIMES"    :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "EIGHT_TIMES"   :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "SIXTEEN_TIMES" : "THIRTYTWO_TIMES";

reg [MEM_DATA_WIDTH-1:0] ram[MEM_DEPTH-1:0];
reg [RDATA_WIDTH-1:0]    r_rdata_1P;
reg [RDATA_WIDTH-1:0]    r_rdata_2P;

wire                     re_int;

generate
    if (FAMILY == "TRION") begin
        if (RDATA_WDATA_RATIO == "ONE") begin
            always @ (posedge wclk) begin
                if (we)
                    ram[waddr] <= wdata;
            end
    
            always @ (posedge rclk) begin
                if (re_int) begin
                    r_rdata_1P <= ram[raddr];
                end
                r_rdata_2P <= r_rdata_1P;
            end
        end
        
        else if (RDATA_WDATA_RATIO == "ONE_THIRTYTWO" || RDATA_WDATA_RATIO == "ONE_SIXTEENTH" || RDATA_WDATA_RATIO == "ONE_EIGHTH" || RDATA_WDATA_RATIO == "ONE_FOURTH"  || RDATA_WDATA_RATIO == "ONE_HALF" ) begin
            if (ENDIANESS == 0) begin 
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
                	for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (we) begin
                            ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                end
                always @ (posedge rclk) begin 
                	if (re_int) begin
                		r_rdata_1P <= ram[raddr];
                    end
                		r_rdata_2P <= r_rdata_1P;
                end
            end
            else begin //endianess == 1
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (we) begin
                            ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                end
                always @ (posedge rclk) begin 
                	if (re_int) begin
                		r_rdata_1P <= ram[raddr];
                	end
                		r_rdata_2P <= r_rdata_1P;
                end
            end
        end
        
        else if (RDATA_WDATA_RATIO == "TWO_TIMES" || RDATA_WDATA_RATIO == "FOUR_TIMES"  || RDATA_WDATA_RATIO == "EIGHT_TIMES"  || RDATA_WDATA_RATIO == "SIXTEEN_TIMES"  ||RDATA_WDATA_RATIO == "THIRTYTWO_TIMES" ) begin
            //integer i;
        	//reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        	if (ENDIANESS == 0) begin
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr; 
        		always @ (posedge rclk) begin
        			for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    	end
                        	r_rdata_2P <= r_rdata_1P;
                    end
                end 
            end
            else begin //endianess == 1
            	always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        		always @ (posedge rclk) begin
        			for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    	end
                        	r_rdata_2P <= r_rdata_1P;
                    end
                end
            end
        end
        if (OUTPUT_REG) begin
            assign re_int = re;
            assign rdata  = r_rdata_2P;            
        end
        else begin
            assign re_int = re;
            assign rdata  = r_rdata_1P;
        end
    end
    else if (FAMILY == "TITANIUM") begin
        if (RDATA_WDATA_RATIO == "ONE") begin
            always @ (posedge wclk) begin
                if (we)
                    ram[waddr] <= wdata;
            end
    
            always @ (posedge rclk) begin
                if (re_int) begin
                    r_rdata_1P <= ram[raddr];
                    r_rdata_2P <= r_rdata_1P;
                end
            end
        end 
        else if (RDATA_WDATA_RATIO == "ONE_THIRTYTWO" || RDATA_WDATA_RATIO == "ONE_SIXTEENTH" || RDATA_WDATA_RATIO == "ONE_EIGHTH" || RDATA_WDATA_RATIO == "ONE_FOURTH"  || RDATA_WDATA_RATIO == "ONE_HALF" ) begin
            //integer i;
            //reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            if (ENDIANESS == 0) begin
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (we) begin
                            	ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                 end
               	always @ (posedge rclk) begin 
               		if (re_int) begin
               			r_rdata_1P <= ram[raddr];
               			r_rdata_2P <= r_rdata_1P;
               		end
               	end
            end
            
            else begin //endianess == 1
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (we) begin
                            	ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                 end
               	always @ (posedge rclk) begin 
               		if (re_int) begin
               			r_rdata_1P <= ram[raddr];
               			r_rdata_2P <= r_rdata_1P;
               		end
               	end
            end
        end
        else if (RDATA_WDATA_RATIO == "TWO_TIMES" || RDATA_WDATA_RATIO == "FOUR_TIMES"  || RDATA_WDATA_RATIO == "EIGHT_TIMES"  || RDATA_WDATA_RATIO == "SIXTEEN_TIMES"  || RDATA_WDATA_RATIO == "THIRTYTWO_TIMES" ) begin
        	//integer i;
            //reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        	if (ENDIANESS == 0) begin
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;        
            	always @ (posedge rclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    		r_rdata_2P                                                               <= r_rdata_1P;
                    	end
                    end
                end 
            end
            
            else begin //endianess ==1
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr;        
            	always @ (posedge rclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    		r_rdata_2P                                                               <= r_rdata_1P;
                    	end
                    end
                end 
            end
        end
        if (MODE == "STANDARD") begin     
            if (OUTPUT_REG) begin
                reg re_r;
                always @ (posedge rclk) begin
                    re_r <= re;
                end
                assign re_int = re | re_r;        
                assign rdata  = r_rdata_2P;            
            end
            else begin
                assign re_int = re;
                assign rdata  = r_rdata_1P;
            end
        end
        else begin
            assign re_int = re;
            assign rdata  = r_rdata_1P;
        end        
    end
endgenerate

endmodule

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2021 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_top) # (
    parameter FAMILY             = "TRION",       // New Param
    parameter SYNC_CLK           = 0,
    parameter BYPASS_RESET_SYNC  = 0,             // New Param
    parameter SYNC_STAGE         = 2,             // New Param
    parameter MODE               = "STANDARD",
    parameter DEPTH              = 512,           // Reverted (Equivalent to WDATA_DEPTH) 
    parameter DATA_WIDTH         = 32,            // Reverted (Equivalent to WDATA_WIDTH)
    parameter PIPELINE_REG       = 1,             // Reverted (By default is ON)
    parameter OPTIONAL_FLAGS     = 1,             // Reverted
    parameter OUTPUT_REG         = 0,
    parameter PROGRAMMABLE_FULL  = "STATIC_DUAL", // Set to "NONE" if not require this feature
    parameter PROG_FULL_ASSERT   = 27,
    parameter PROG_FULL_NEGATE   = 23,
    parameter PROGRAMMABLE_EMPTY = "STATIC_DUAL", // Set to "NONE" if not require this feature
    parameter PROG_EMPTY_ASSERT  = 5,
    parameter PROG_EMPTY_NEGATE  = 7,
    parameter ALMOST_FLAG        = OPTIONAL_FLAGS,
    parameter HANDSHAKE_FLAG     = OPTIONAL_FLAGS,
    parameter ASYM_WIDTH_RATIO   = 4,
    parameter WADDR_WIDTH        = depth2width(DEPTH),
    parameter RDATA_WIDTH        = rdwidthcompute(ASYM_WIDTH_RATIO,DATA_WIDTH),
    parameter RD_DEPTH           = rddepthcompute(DEPTH,DATA_WIDTH,RDATA_WIDTH),
    parameter RADDR_WIDTH        = depth2width(RD_DEPTH),
    parameter ENDIANESS		 = 0

)(
    input  wire                   a_rst_i,
    input  wire                   a_wr_rst_i,
    input  wire                   a_rd_rst_i,
    input  wire                   clk_i,
    input  wire                   wr_clk_i,
    input  wire                   rd_clk_i,
    input  wire                   wr_en_i,
    input  wire                   rd_en_i,
    input  wire [DATA_WIDTH-1:0]  wdata,
    output wire                   almost_full_o,
    output wire                   prog_full_o,
    output wire                   full_o,
    output wire                   overflow_o,
    output wire                   wr_ack_o,
    output wire [WADDR_WIDTH :0]  datacount_o,
    output wire [WADDR_WIDTH :0]  wr_datacount_o,
    output wire                   empty_o,
    output wire                   almost_empty_o,
    output wire                   prog_empty_o,
    output wire                   underflow_o,
    output wire                   rd_valid_o,
    output wire [RDATA_WIDTH-1:0] rdata,
    output wire [RADDR_WIDTH :0]  rd_datacount_o,
    output wire                   rst_busy
); 

localparam WR_DEPTH      = DEPTH;
localparam WDATA_WIDTH   = DATA_WIDTH;
localparam RAM_MUX_RATIO = (RDATA_WIDTH <= WDATA_WIDTH/32) ? 32 :
                           (RDATA_WIDTH <= WDATA_WIDTH/16) ? 16 :
                           (RDATA_WIDTH <= WDATA_WIDTH/8)  ? 8  :
                           (RDATA_WIDTH <= WDATA_WIDTH/4)  ? 4  :
                           (RDATA_WIDTH <= WDATA_WIDTH/2)  ? 2  :
                           (RDATA_WIDTH <= WDATA_WIDTH)    ? 1  :
                           (RDATA_WIDTH <= WDATA_WIDTH*2)  ? 2  :
                           (RDATA_WIDTH <= WDATA_WIDTH*4)  ? 4  :
                           (RDATA_WIDTH <= WDATA_WIDTH*8)  ? 8  :
                           (RDATA_WIDTH <= WDATA_WIDTH*16) ? 16 : 32;           

wire                   wr_rst_int;
wire                   rd_rst_int;
wire                   wr_en_int;
wire                   rd_en_int;
wire [WADDR_WIDTH-1:0] waddr;
wire [RADDR_WIDTH-1:0] raddr;
wire                   wr_clk_int;
wire                   rd_clk_int;
wire [WADDR_WIDTH :0]  wr_datacount_int;
wire [RADDR_WIDTH :0]  rd_datacount_int;

generate
    if (ASYM_WIDTH_RATIO == 4) begin
        if (SYNC_CLK) begin
            assign wr_clk_int     = clk_i;    
            assign rd_clk_int     = clk_i;
            assign datacount_o    = wr_datacount_int;
            assign wr_datacount_o = 'd0;
            assign rd_datacount_o = 'd0;
        end
        else begin
            assign wr_clk_int     = wr_clk_i;    
            assign rd_clk_int     = rd_clk_i;
            assign datacount_o    = 'd0;
            assign wr_datacount_o = wr_datacount_int;
            assign rd_datacount_o = rd_datacount_int;
        end
    end
    else begin
        assign datacount_o    = 'd0;
        assign wr_datacount_o = wr_datacount_int;
        assign rd_datacount_o = rd_datacount_int;
        if (SYNC_CLK) begin
            assign wr_clk_int     = clk_i;    
            assign rd_clk_int     = clk_i;
        end
        else begin
            assign wr_clk_int     = wr_clk_i;    
            assign rd_clk_int     = rd_clk_i;
        end
    end    

    if (!SYNC_CLK) begin
        (* async_reg = "true" *) reg [1:0] wr_rst;
        (* async_reg = "true" *) reg [1:0] rd_rst;
        
        always @ (posedge wr_clk_int or posedge a_rst_i) begin
            if (a_rst_i) 
                wr_rst <= 2'b11;
            else 
                wr_rst <= {wr_rst[0],1'b0};            
        end
        
        always @ (posedge rd_clk_int or posedge a_rst_i) begin
            if (a_rst_i) 
                rd_rst <= 2'b11;
            else 
                rd_rst <= {rd_rst[0],1'b0};            
        end

        if (BYPASS_RESET_SYNC) begin
            assign wr_rst_int = a_wr_rst_i;
            assign rd_rst_int = a_rd_rst_i; 
            assign rst_busy   = 1'b0;
        end 
        else begin
            assign wr_rst_int = wr_rst[1];
            assign rd_rst_int = rd_rst[1]; 
            assign rst_busy   = wr_rst_int | rd_rst_int;
        end
    end
    else begin
        (* async_reg = "true" *) reg [1:0] a_rst;
        
        always @ (posedge clk_i or posedge a_rst_i) begin
            if (a_rst_i) 
                a_rst <= 2'b11;
            else 
                a_rst <= {a_rst[0],1'b0};            
        end

        if (BYPASS_RESET_SYNC) begin
            assign wr_rst_int = a_rst_i;
            assign rd_rst_int = a_rst_i;
            assign rst_busy   = 1'b0;
        end
        else begin
            assign wr_rst_int = a_rst[1];
            assign rd_rst_int = a_rst[1];   
            assign rst_busy   = wr_rst_int | rd_rst_int;
        end
    end 
endgenerate

`IP_MODULE_NAME(efx_fifo_ram) # (
    .FAMILY        (FAMILY),
    .MODE          (MODE),
    .WR_DEPTH      (WR_DEPTH),
    .RD_DEPTH      (RD_DEPTH),
    .WDATA_WIDTH   (WDATA_WIDTH),
    .RDATA_WIDTH   (RDATA_WIDTH),
    .WADDR_WIDTH   (WADDR_WIDTH),
    .RADDR_WIDTH   (RADDR_WIDTH),
    .OUTPUT_REG    (OUTPUT_REG),
    .RAM_MUX_RATIO (RAM_MUX_RATIO),
    .ENDIANESS	   (ENDIANESS)
) xefx_fifo_ram (
    .wdata (wdata), 
    .waddr (waddr),
    .raddr (raddr), 
    .we    (wr_en_int), 
    .re    (rd_en_int),
    .wclk  (wr_clk_int),
    .rclk  (rd_clk_int),
    .rdata (rdata)
);

`IP_MODULE_NAME(efx_fifo_ctl) # (
    .FAMILY             (FAMILY),
    .SYNC_CLK           (SYNC_CLK),
    .SYNC_STAGE         (SYNC_STAGE),
    .MODE               (MODE),
    .WR_DEPTH           (WR_DEPTH),
    .WADDR_WIDTH        (WADDR_WIDTH),
    .RADDR_WIDTH        (RADDR_WIDTH),
    .ASYM_WIDTH_RATIO   (ASYM_WIDTH_RATIO),
    .RAM_MUX_RATIO      (RAM_MUX_RATIO),
    .PIPELINE_REG       (PIPELINE_REG),
    .ALMOST_FLAG        (ALMOST_FLAG),
    .PROGRAMMABLE_FULL  (PROGRAMMABLE_FULL),
    .PROG_FULL_ASSERT   (PROG_FULL_ASSERT),
    .PROG_FULL_NEGATE   (PROG_FULL_NEGATE),
    .PROGRAMMABLE_EMPTY (PROGRAMMABLE_EMPTY),
    .PROG_EMPTY_ASSERT  (PROG_EMPTY_ASSERT),
    .PROG_EMPTY_NEGATE  (PROG_EMPTY_NEGATE),
    .OUTPUT_REG         (OUTPUT_REG),
    .HANDSHAKE_FLAG     (HANDSHAKE_FLAG)
) xefx_fifo_ctl (
    .wr_rst          (wr_rst_int),
    .rd_rst          (rd_rst_int),
    .wclk            (wr_clk_int),
    .rclk            (rd_clk_int),
    .we              (wr_en_i),
    .re              (rd_en_i),
    .wr_full         (full_o),
    .wr_ack          (wr_ack_o),
    .rd_empty        (empty_o),
    .wr_almost_full  (almost_full_o),
    .rd_almost_empty (almost_empty_o),
    .wr_prog_full    (prog_full_o),
    .rd_prog_empty   (prog_empty_o),
    .wr_en_int       (wr_en_int),
    .rd_en_int       (rd_en_int),
    .waddr           (waddr),
    .raddr           (raddr),
    .wr_datacount    (wr_datacount_int),
    .rd_datacount    (rd_datacount_int),
    .rd_vld          (rd_valid_o),
    .wr_overflow     (overflow_o),
    .rd_underflow    (underflow_o)
);

function integer depth2width;
input [31:0] depth;
begin : fnDepth2Width
    if (depth > 1) begin
        depth = depth - 1;
        for (depth2width=0; depth>0; depth2width = depth2width + 1)
            depth = depth>>1;
        end
    else
    depth2width = 0;
end
endfunction 

function integer width2depth;
input [31:0] width;
begin : fnWidth2Depth
    width2depth = width**2;
end
endfunction

function integer rdwidthcompute;
input [31:0] asym_option;
input [31:0] wr_width;
begin : RdWidthCompute
    rdwidthcompute = (asym_option==0)? wr_width/16 :
                     (asym_option==1)? wr_width/8  :
                     (asym_option==2)? wr_width/4  :
                     (asym_option==3)? wr_width/2  :
                     (asym_option==4)? wr_width/1  :
                     (asym_option==5)? wr_width*2  :
                     (asym_option==6)? wr_width*4  :
                     (asym_option==7)? wr_width*8  :
                     (asym_option==8)? wr_width*16 : wr_width/1;
end
endfunction

function integer rddepthcompute;
input [31:0] wr_depth;
input [31:0] wr_width;
input [31:0] rd_width;
begin : RdDepthCompute
    rddepthcompute = (wr_depth * wr_width) / rd_width;
end
endfunction

endmodule


////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   bin2gray.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Binary to Gray Encoding Convertor
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns/1ps

module `IP_MODULE_NAME(efx_fifo_bin2gray)
#(parameter WIDTH=5)
(// outputs
 output wire [WIDTH-1:0] gray_o,
 // input
 input [WIDTH-1:0] bin_i
 );

//---------------------------------------------------------------------
// Function :   bit_xor
// Description: reduction xor
function bit_xor (
  input [31:0] nex_bit,
  input [31:0] curr_bit,
  input [WIDTH-1:0] xor_in);
  begin : fn_bit_xor
    bit_xor = xor_in[nex_bit] ^ xor_in[curr_bit];
  end
endfunction

// Convert Binary to Gray, bit by bit
generate 
begin
  genvar bit_idx;
  for(bit_idx=0; bit_idx<WIDTH-1; bit_idx=bit_idx+1) begin : gBinBits
    assign gray_o[bit_idx] = bit_xor(bit_idx+1, bit_idx, bin_i);
  end
  assign   gray_o[WIDTH-1] = bin_i[WIDTH-1];
end
endgenerate

endmodule 

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_ctl) # (
    parameter FAMILY             = "TRION",
    parameter SYNC_CLK           = 1,
    parameter SYNC_STAGE         = 2,
    parameter MODE               = "STANDARD",
    parameter WR_DEPTH           = 512,
    parameter WADDR_WIDTH        = 9,
    parameter RADDR_WIDTH        = 9,
    parameter ASYM_WIDTH_RATIO   = 4,
    parameter RAM_MUX_RATIO      = 1,
    parameter PIPELINE_REG       = 1,
    parameter ALMOST_FLAG        = 1,
    parameter PROGRAMMABLE_FULL  = "NONE",
    parameter PROG_FULL_ASSERT   = 0,
    parameter PROG_FULL_NEGATE   = 0,
    parameter PROGRAMMABLE_EMPTY = "NONE",
    parameter PROG_EMPTY_ASSERT  = 0,
    parameter PROG_EMPTY_NEGATE  = 0,
    parameter OUTPUT_REG         = 0,
    parameter HANDSHAKE_FLAG     = 1
)(
    input   wire                   wr_rst,
    input   wire                   rd_rst,
    input   wire                   wclk,
    input   wire                   rclk,
    input   wire                   we,
    input   wire                   re,
    output  wire                   wr_full,
    output  reg                    wr_ack,
    output  wire                   wr_almost_full,
    output  wire                   rd_empty,
    output  wire                   rd_almost_empty,
    output  wire                   wr_prog_full,
    output  wire                   rd_prog_empty,
    output  wire                   wr_en_int,
    output  wire                   rd_en_int,
    output  wire [WADDR_WIDTH-1:0] waddr,
    output  wire [RADDR_WIDTH-1:0] raddr,
    output  wire [WADDR_WIDTH:0]   wr_datacount,
    output  wire [RADDR_WIDTH:0]   rd_datacount,
    output  wire                   rd_vld,
    output  reg                    wr_overflow,
    output  reg                    rd_underflow
);

reg  [WADDR_WIDTH:0] waddr_cntr;
reg  [RADDR_WIDTH:0] raddr_cntr;
reg  [RADDR_WIDTH:0] raddr_cntr_r;
reg                  rd_valid;

wire [RADDR_WIDTH:0] raddr_cntr_w;
wire [WADDR_WIDTH:0] waddr_int;
wire [RADDR_WIDTH:0] raddr_int;
wire [RADDR_WIDTH:0] raddr_int_dcount;
wire [RADDR_WIDTH:0] raddr_dcount;
wire                 rd_empty_int;
wire [WADDR_WIDTH:0] wr_datacount_int;
wire [RADDR_WIDTH:0] rd_datacount_int;

assign waddr     = waddr_cntr[WADDR_WIDTH-1:0];
assign raddr     = raddr_cntr[RADDR_WIDTH-1:0];
assign wr_en_int = we & ~wr_full;

generate
    if (MODE == "FWFT") begin    
        reg init_set;
        reg rd_empty_fwft;
        assign rd_en_int     = (~rd_empty_int & rd_empty) | (re & ~rd_empty_int);
        assign rd_empty      = rd_empty_fwft;
        assign raddr_cntr_w  = ~rd_empty ? raddr_cntr_r/*raddr_cntr-1*/ : raddr_cntr;
        
        if (ASYM_WIDTH_RATIO < 4) begin
            assign wr_datacount  = wr_datacount_int;
            assign rd_datacount  = rd_empty ? rd_datacount_int : ~init_set ? (rd_datacount_int+1'b1) : rd_datacount_int;
        end
        else begin
            assign wr_datacount  = wr_datacount_int;
            assign rd_datacount  = rd_datacount_int;        
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                init_set <= 1'b1;
            end
            else if (~init_set & rd_empty) begin
                init_set <= 1'b1;            
            end
            else if (~rd_empty_int) begin
                init_set <= 1'b0;            
            end
            else if (rd_empty) begin
                init_set <= 1'b1;            
            end
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_empty_fwft <= 1'b1;
            end
            else if (rd_en_int) begin
                rd_empty_fwft <= 1'b0;            
            end
            else if (re) begin
                rd_empty_fwft <= 1'b1;            
            end
        end          
        
        if (FAMILY == "TRION") begin
            if (OUTPUT_REG) begin
                always @ (posedge rclk or posedge rd_rst) begin
                    if (rd_rst) begin
                        rd_valid <= 1'b0;
                    end
                    else begin
                        rd_valid <= ~rd_empty;
                    end
                end
                assign rd_vld = rd_valid;                
            end    
            else begin
                assign rd_vld = ~rd_empty;                
            end
        end
        else begin
            assign rd_vld = ~rd_empty;
        end
    end
    else begin
        assign rd_en_int     = re & ~rd_empty_int;
        assign rd_empty      = rd_empty_int;
        assign raddr_cntr_w  = raddr_cntr;
        assign wr_datacount  = wr_datacount_int;
        assign rd_datacount  = rd_datacount_int;
        
        if (OUTPUT_REG) begin
            reg rd_valid_r;
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    rd_valid_r <= 'h0;
                    rd_valid   <= 'h0;
                end
                else begin
                    {rd_valid,rd_valid_r} <= {rd_valid_r,rd_en_int};
                end
            end
            assign rd_vld = rd_valid;            
        end
        else begin
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    rd_valid  <= 'h0;
                end
                else begin
                    rd_valid <= rd_en_int;
                end
            end
            assign rd_vld = rd_valid;
        end
    end
    
    if (ALMOST_FLAG) begin
        assign wr_almost_full   = wr_datacount_int >= WR_DEPTH-1;
        assign rd_almost_empty  = rd_datacount_int <= 'd1;  
    end
    else begin
        assign wr_almost_full   = 1'b0;
        assign rd_almost_empty  = 1'b0;        
    end
    
    if (PROGRAMMABLE_FULL == "STATIC_SINGLE") begin
        reg    wr_prog_full_int;
        assign wr_prog_full  = wr_datacount >= PROG_FULL_ASSERT;
        
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_prog_full_int  <= 1'b0;
            end
            else begin
                wr_prog_full_int  <= wr_prog_full;
            end
        end  
    end
    else if (PROGRAMMABLE_FULL == "STATIC_DUAL") begin
        reg    wr_prog_full_int;
        assign wr_prog_full  = wr_prog_full_int ? wr_datacount >= PROG_FULL_NEGATE : wr_datacount >= PROG_FULL_ASSERT;   

        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_prog_full_int  <= 1'b0;
            end
            else begin
                wr_prog_full_int  <= wr_prog_full;
            end
        end              
    end
    else begin
        assign wr_prog_full  = 1'b0; 
    end
        
    if (PROGRAMMABLE_EMPTY == "STATIC_SINGLE") begin
        reg    rd_prog_empty_int;
        assign rd_prog_empty  = rd_datacount <= PROG_EMPTY_ASSERT;
            
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_prog_empty_int <= 1'b1;
            end
            else begin
                rd_prog_empty_int <= rd_prog_empty;
            end
        end
    end
    else if (PROGRAMMABLE_EMPTY == "STATIC_DUAL") begin
        reg    rd_prog_empty_int;
        assign rd_prog_empty = rd_prog_empty_int ? (rd_datacount <= PROG_EMPTY_NEGATE) : (rd_datacount <= PROG_EMPTY_ASSERT);
            
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_prog_empty_int <= 1'b1;
            end
            else begin
                rd_prog_empty_int <= rd_prog_empty;
            end
        end  
    end
    else begin
        assign rd_prog_empty  = 1'b0; 
    end
    
    if (HANDSHAKE_FLAG) begin
    
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_ack <= 1'b0;
            end
            else begin
                wr_ack <= wr_en_int & ~wr_overflow;
            end
        end

        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_overflow <= 1'b0;
            end
            else if (we && wr_full) begin
                wr_overflow <= 1'b1;
            end
            else begin
                wr_overflow <= 1'b0;            
            end
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_underflow <= 1'b0;
            end
            else if (re && rd_empty) begin
                rd_underflow <= 1'b1;
            end
            else begin
                rd_underflow <= 1'b0;            
            end
        end
    end
    
    localparam RATIO_WIDTH = (RADDR_WIDTH >= WADDR_WIDTH)? RADDR_WIDTH - WADDR_WIDTH : WADDR_WIDTH - RADDR_WIDTH;
    
    if (ASYM_WIDTH_RATIO < 4) begin
        assign wr_full          = (waddr_cntr[WADDR_WIDTH]^raddr_int[RADDR_WIDTH]) & (waddr_cntr[WADDR_WIDTH-1:0] == raddr_int[RADDR_WIDTH-1:RATIO_WIDTH]);
        assign rd_empty_int     = waddr_int[WADDR_WIDTH:0] == raddr_cntr[RADDR_WIDTH:RATIO_WIDTH];
        assign wr_datacount_int = waddr_cntr - (raddr_int/RAM_MUX_RATIO);
        assign rd_datacount_int = (waddr_int*RAM_MUX_RATIO)-raddr_cntr;
    end
    else begin
        assign wr_full          = (waddr_cntr[WADDR_WIDTH]^raddr_int[RADDR_WIDTH]) & (waddr_cntr[WADDR_WIDTH-1:RATIO_WIDTH] == raddr_int[RADDR_WIDTH-1:0]);
        assign rd_empty_int     = (waddr_int- raddr_cntr*RAM_MUX_RATIO) < RAM_MUX_RATIO;
        assign wr_datacount_int = waddr_cntr - (raddr_int*RAM_MUX_RATIO);
        assign rd_datacount_int = (waddr_int/RAM_MUX_RATIO)-raddr_cntr_w;
    end
endgenerate

always @ (posedge wclk or posedge wr_rst) begin
    if (wr_rst) begin
        waddr_cntr <= 'h0;
    end
    else if (wr_en_int) begin
        waddr_cntr <= waddr_cntr + 1'b1;
    end
end

always @ (posedge rclk or posedge rd_rst) begin
    if (rd_rst) begin
        raddr_cntr   <= 'h0;
        raddr_cntr_r <= 'h0;
    end
    else if (rd_en_int) begin
        raddr_cntr   <= raddr_cntr + 1'b1;
        raddr_cntr_r <= raddr_cntr;
    end
end

generate
    if (SYNC_CLK) begin
        assign waddr_int        = waddr_cntr;
        assign raddr_int        = raddr_cntr_w;
    end
    else begin
        reg  [RADDR_WIDTH:0] raddr_cntr_gry_r;
        reg  [WADDR_WIDTH:0] waddr_cntr_gry_r;
        
        wire [RADDR_WIDTH:0] raddr_cntr_gry;
        wire [RADDR_WIDTH:0] raddr_cntr_gry_sync;
        wire [RADDR_WIDTH:0] raddr_cntr_sync_g2b;
        wire [WADDR_WIDTH:0] waddr_cntr_gry;
        wire [WADDR_WIDTH:0] waddr_cntr_gry_sync;
        wire [WADDR_WIDTH:0] waddr_cntr_sync_g2b;

        if (PIPELINE_REG) begin
            reg  [RADDR_WIDTH:0] raddr_cntr_sync_g2b_r;    
            reg  [WADDR_WIDTH:0] waddr_cntr_sync_g2b_r;        
        
            assign waddr_int        = waddr_cntr_sync_g2b_r;
            assign raddr_int        = raddr_cntr_sync_g2b_r;
            
            always @ (posedge wclk or posedge wr_rst) begin
                if (wr_rst) begin
                    raddr_cntr_sync_g2b_r <= 'h0;
                end
                else begin
                    raddr_cntr_sync_g2b_r <= raddr_cntr_sync_g2b;
                end
            end
            
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    waddr_cntr_sync_g2b_r <= 'h0;
                end
                else begin
                    waddr_cntr_sync_g2b_r <= waddr_cntr_sync_g2b;
                end
            end
        end
        else begin
            assign waddr_int        = waddr_cntr_sync_g2b;
            assign raddr_int        = raddr_cntr_sync_g2b;        
        end
      
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                raddr_cntr_gry_r <= 'h0;
            end
            else begin
                raddr_cntr_gry_r <= raddr_cntr_gry;
            end
        end
        `IP_MODULE_NAME(efx_fifo_bin2gray) # (.WIDTH(RADDR_WIDTH+1)                     ) xrd2wr_bin2gray    (.bin_i(raddr_cntr_w), .gray_o(raddr_cntr_gry));
        `IP_MODULE_NAME(efx_fifo_datasync) # (.STAGE(SYNC_STAGE), .WIDTH (RADDR_WIDTH+1)) xrd2wr_addr_sync   (.clk_i(wclk), .d_i(raddr_cntr_gry_r), .d_o(raddr_cntr_gry_sync));
        `IP_MODULE_NAME(efx_fifo_gray2bin) # (.WIDTH(RADDR_WIDTH+1)                     ) xrd2wr_gray2bin    (.gray_i(raddr_cntr_gry_sync), .bin_o(raddr_cntr_sync_g2b));
        
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                waddr_cntr_gry_r <= 'h0;
            end
            else begin
                waddr_cntr_gry_r <= waddr_cntr_gry;
            end
        end        
        `IP_MODULE_NAME(efx_fifo_bin2gray) # (.WIDTH(WADDR_WIDTH+1)                     ) wr2rd_bin2gray  (.bin_i(waddr_cntr), .gray_o(waddr_cntr_gry));
        `IP_MODULE_NAME(efx_fifo_datasync) # (.STAGE(SYNC_STAGE), .WIDTH (WADDR_WIDTH+1)) wr2rd_addr_sync (.clk_i(rclk), .d_i(waddr_cntr_gry_r), .d_o(waddr_cntr_gry_sync));
        `IP_MODULE_NAME(efx_fifo_gray2bin) # (.WIDTH(WADDR_WIDTH+1)                     ) wr2rd_gray2bin  (.gray_i(waddr_cntr_gry_sync), .bin_o(waddr_cntr_sync_g2b));        

    end
endgenerate
endmodule



// synopsys translate_off
`timescale 1 ns / 1 ps													
// synopsys translate_on

module `IP_MODULE_NAME(efx_asyncreg) #(
    parameter ASYNC_STAGE = 2,
    parameter WIDTH = 4,
    parameter ACTIVE_LOW = 1
) (
    input  wire             clk,
    input  wire             reset_n,
    input  wire [WIDTH-1:0] d_i,
    output wire [WIDTH-1:0] d_o
);

(* async_reg = "true" *) reg [WIDTH-1:0] async_reg[ASYNC_STAGE-1:0];

assign d_o = async_reg[ASYNC_STAGE-1];

genvar i;
generate
   if (ACTIVE_LOW == 1) begin: active_low
      always @ (posedge clk or negedge reset_n)
      begin
          if(!reset_n) begin
              async_reg[0]         <= {WIDTH{1'b0}};
          end
          else begin 
              async_reg[0]         <= d_i;
          end
      end
          
      for (i=1; i<ASYNC_STAGE; i=i+1) begin
          always @ (posedge clk or negedge reset_n)
          begin
              if(!reset_n) begin
                  async_reg[i]         <= {WIDTH{1'b0}};
              end
              else begin 
                  async_reg[i]         <= async_reg[i-1];
              end
          end
      end
   end
   else begin: active_high
      always @ (posedge clk or posedge reset_n)
      begin
          if(reset_n) begin
              async_reg[0]         <= {WIDTH{1'b0}};
          end
          else begin 
              async_reg[0]         <= d_i;
          end
      end
          
      for (i=1; i<ASYNC_STAGE; i=i+1) begin
          always @ (posedge clk or posedge reset_n)
          begin
              if(reset_n) begin
                  async_reg[i]         <= {WIDTH{1'b0}};
              end
              else begin 
                  async_reg[i]         <= async_reg[i-1];
              end
          end
      end
   end
endgenerate

endmodule



// synopsys translate_off
`timescale 1 ns / 1 ps													
// synopsys translate_on

module `IP_MODULE_NAME(efx_resetsync) #(
    parameter ASYNC_STAGE = 2,
    parameter ACTIVE_LOW = 1
) (
    input  wire             clk,
    input  wire             reset,
    output wire             d_o
);

(* async_reg = "true" *) reg [ASYNC_STAGE-1:0] async_reg;

assign d_o = async_reg[ASYNC_STAGE-1];

genvar i;
generate
   if (ACTIVE_LOW == 1) begin: active_low
      always @ (posedge clk or negedge reset)
      begin
          if(!reset) begin
              async_reg[0]         <= 1'b0;
          end
          else begin 
              async_reg[0]         <= 1'b1;
          end
      end
          
      for (i=1; i<ASYNC_STAGE; i=i+1) begin
          always @ (posedge clk or negedge reset)
          begin
              if(!reset) begin
                  async_reg[i]         <= 1'b0;
              end
              else begin 
                  async_reg[i]         <= async_reg[i-1];
              end
          end
      end
   end
   else begin: active_high
      always @ (posedge clk or posedge reset)
      begin
          if(reset) begin
              async_reg[0]         <= 1'b1;
          end
          else begin 
              async_reg[0]         <= 1'b0;
          end
      end
          
      for (i=1; i<ASYNC_STAGE; i=i+1) begin
          always @ (posedge clk or posedge reset)
          begin
              if(reset) begin
                  async_reg[i]         <= 1'b1;
              end
              else begin 
                  async_reg[i]         <= async_reg[i-1];
              end
          end
      end
   end
endgenerate

endmodule




// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_user_if) # (
    parameter AXI_DBW  = 32,
    parameter RAM_DBW  = 16,
    parameter D_RATIO  = 4,
    parameter DUAL_RAM = 1,
    parameter RAM_2DBW = (DUAL_RAM == 1)? RAM_DBW*4 : RAM_DBW * 2,
    parameter RAM_DMW  = RAM_2DBW / 8
)(
    input  wire                clk,
    input  wire                rst_n,
    input  wire                ax_valid,
    input  wire                ax_type,
    input  wire [7:0]          ax_id,      
    input  wire [7:0]          ax_len,     
    input  wire [2:0]          ax_size,    
    input  wire [1:0]          ax_burst,   
    input  wire [31:0]         ax_addr,
    output wire                ax_ready,
    input  wire                w_valid,
    input  wire [RAM_2DBW-1:0] w_data,
    input  wire [RAM_DMW-1:0]  w_strb,
    input  wire                w_last,
    output wire                w_ready,
    input  wire                b_ready,
    output wire [7:0]          b_id,
    output wire                b_valid,
    output wire [1:0]          b_resp,
    input  wire                r_ready,
    output wire                r_valid,
    output wire [RAM_2DBW-1:0] r_data,
    output wire [7:0]          r_id,
    output wire [1:0]          r_resp,
    output wire                r_last,
    input  wire                h_wrdy,
    input  wire                h_mrdy,
    input  wire [RAM_2DBW-1:0] h_rdata,
    input  wire                h_rdav,
    input  wire                h_pause,
    output wire                h_rwen,
    output wire                h_req,
    output reg  [31:0]         h_addr,
    output wire [RAM_2DBW-1:0] h_wdata,
    output wire [RAM_DMW-1:0]  h_wdm,
    output wire                h_last,
    output reg                 h_ctc,
    output wire                h_btype,
    output wire                h_atype,
    output wire	[7:0] h_rlen
);
reg [3:0]  state;
reg [3:0]  next_state;
reg        init_done;
reg        ctrl_idle;
reg        axi_wr_req_1;
reg        axi_wr_req_2;
reg        ctrl_rd_req_1;
reg        ctrl_rd_req_2;
reg        wr_fetch;
reg        fetch_done;
reg        b_resp_int;
reg [11:0] burst_cntr;
reg [2:0]  h_pause_r;
reg        h_ctc_int;
reg [1:0]  h_wrdy_r;
reg [31:0] addr_align;
reg [7:0]  ax_len_r;
reg [2:0]  wreq_cntr;
reg        wlen0_pull;
wire      wdata_req;
wire      pull_data;
wire      burst_hit;
wire      pre_burst_hit;
assign h_req       = axi_wr_req_2 | ctrl_rd_req_2;
assign h_wdata     = (axi_wr_req_2 & ~h_wrdy_r[1])? {RAM_2DBW{1'b0}} : w_data;
assign h_wdm       = (axi_wr_req_2 & ~h_wrdy_r[1])? {RAM_DMW{1'b1}}  : ~w_strb;
assign h_last      = (axi_wr_req_2 & w_valid & w_last) | r_last;
assign h_btype     = ax_burst[0];
assign h_atype     = ax_addr[31];
assign h_rwen      = ~ax_type;
assign ax_ready = init_done & ctrl_idle;
assign w_ready  = axi_wr_req_1 | (pull_data/*axi_wr_req_2 & h_wrdy*/ & ~(|h_pause_r[2:1]) /*& ~pre_burst_hit*/);
assign b_valid  = (axi_wr_req_1 & w_valid) ? 1'b1 :1'b0;
assign b_id     = (axi_wr_req_1 & w_valid) ? ax_id :8'd0;
assign b_resp   = 2'b00;
assign r_data   = h_rdata;
assign r_valid  = ctrl_rd_req_2 & h_mrdy & h_rdav;
assign r_last   = ctrl_rd_req_2 & burst_hit & h_rdav;
assign r_id     = ax_id;
assign wdata_req = axi_wr_req_2 & h_wrdy;
generate
    if (D_RATIO==1) begin
        assign pull_data = (ax_len_r == 'd0) ? (wdata_req & wreq_cntr == 'd0) : (ax_len_r == 'd1) ? (wdata_req & wreq_cntr <= 'd1) : wdata_req & ~pre_burst_hit & ~burst_hit;
    end
    else begin
        assign pull_data = (ax_len_r == 'd0) ? (wdata_req & wreq_cntr == 'd0) | wlen0_pull : wdata_req & ~pre_burst_hit & ~burst_hit;
    end
endgenerate
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        wlen0_pull = 1'b0;
	end
    else if (wdata_req && wreq_cntr < D_RATIO-1) begin
        wlen0_pull = 1'b1;
    end
    else begin
        wlen0_pull = 1'b0;
    end
end
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        wreq_cntr = 3'd0;
	end
    else if (!axi_wr_req_2) begin
        wreq_cntr = 3'd0;
    end
    else if (wdata_req && wreq_cntr < 7) begin
        wreq_cntr = wreq_cntr + 1'd1;
    end
end
wire [31:0] h_addr_int;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        h_addr   = 32'd0;
        ax_len_r = 8'h0;
    end
    else begin
        h_addr = h_addr_int;
        ax_len_r = ax_len;
    end
end
generate
    if (DUAL_RAM == 1) begin
		if (RAM_DBW == 16) begin 
			assign h_addr_int      = (ax_addr & ~addr_align) >> 3;
		end
		else if (RAM_DBW == 8) begin 
			assign h_addr_int      = (ax_addr & ~addr_align) >> 2;
		end
	end
	else begin
		if (RAM_DBW == 16) begin 
			assign h_addr_int      = (ax_addr & ~addr_align) >> 2;
		end
		else if (RAM_DBW == 8) begin 
			assign h_addr_int      = (ax_addr & ~addr_align) >> 1;
		end
	end
    if (AXI_DBW == 256) begin
        always @ (*) begin
            case (ax_size)
                3'b000  : addr_align = 'h0;
                3'b001  : addr_align = 'h1;
                3'b010  : addr_align = 'h3;
                3'b011  : addr_align = 'h7;
                3'b100  : addr_align = 'hf;
                3'b101  : addr_align = 'h1f;
                default : addr_align = 'h1f;
            endcase
        end
    end
    else if (AXI_DBW == 128) begin
        always @ (*) begin
            case (ax_size)
                3'b000  : addr_align = 'h0;
                3'b001  : addr_align = 'h1;
                3'b010  : addr_align = 'h3;
                3'b011  : addr_align = 'h7;
                3'b100  : addr_align = 'hf;
                default : addr_align = 'hf;
            endcase
        end
    end
    else if (AXI_DBW == 64) begin
        always @ (*) begin
            case (ax_size)
                3'b000  : addr_align = 'h0;
                3'b001  : addr_align = 'h1;
                3'b010  : addr_align = 'h3;
                3'b011  : addr_align = 'h7;
                default : addr_align = 'h7;
            endcase
        end
    end
    else begin
        always @ (*) begin
            case (ax_size)
                3'b000  : addr_align = 'h0;
                3'b001  : addr_align = 'h1;
                3'b010  : addr_align = 'h3;
                default : addr_align = 'h3;
            endcase
        end
    end
endgenerate
parameter INIT           = 0,
          IDLE           = 1,
          NEXT_OPERATION = 2,
          WR_BURST_CHECK = 3,
          WR_BURST_FETCH = 4,
          BRESPONSE      = 5,
          RD_INIT        = 6,
          RD_STREAM      = 7,
          RD_DONE        = 8;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= INIT;
    end
    else begin
        state <= next_state;
    end
end
always @ (*) begin
    case (state)
        INIT           : begin if (h_mrdy)           next_state = IDLE;           else next_state = INIT;           end
        IDLE           : begin if (ax_valid)         next_state = NEXT_OPERATION; else next_state = IDLE;           end
        NEXT_OPERATION : begin if (ax_type)          next_state = WR_BURST_CHECK; else next_state = RD_INIT;        end
        WR_BURST_CHECK : begin if (w_valid)          next_state = WR_BURST_FETCH; else next_state = WR_BURST_CHECK; end
        WR_BURST_FETCH : begin if (w_valid && w_last && burst_hit) next_state = BRESPONSE;      else next_state = WR_BURST_FETCH; end
        BRESPONSE      : begin                                                         next_state = IDLE;           end
        RD_INIT        : begin                                                         next_state = RD_STREAM;      end
        RD_STREAM      : begin if (h_rdav && burst_hit) next_state = RD_DONE;        else next_state = RD_STREAM;      end
        RD_DONE        : begin if (~h_rdav)          next_state = IDLE;           else next_state = RD_DONE;        end
        default        : begin                                                         next_state = IDLE;           end
    endcase
end
always @ (*) begin
    init_done     = 1'b1;
    ctrl_idle     = 1'b0;
    axi_wr_req_1  = 1'b0;
    axi_wr_req_2  = 1'b0;
    wr_fetch      = 1'b0;
    fetch_done    = 1'b0;
    ctrl_rd_req_1 = 1'b0;
    ctrl_rd_req_2 = 1'b0;
    case (state)
        INIT           : begin init_done     = 1'b0;                   end
        IDLE           : begin ctrl_idle     = 1'b1;                   end
        WR_BURST_CHECK : begin axi_wr_req_1  = 1'b1;                   end
        WR_BURST_FETCH : begin axi_wr_req_2  = 1'b1; wr_fetch  = 1'b1; end
        BRESPONSE      : begin fetch_done    = 1'b1;                   end
        RD_INIT        : begin ctrl_rd_req_1 = 1'b1;                   end
        RD_STREAM      : begin ctrl_rd_req_2 = 1'b1;                   end
        default        : begin init_done     = 1'b0;end
    endcase
end
assign h_rlen = ax_len_r;
assign burst_hit     = (burst_cntr == ((ax_len_r + 1) * D_RATIO)-1)? 1'b1:1'b0;
assign pre_burst_hit = (burst_cntr == ((ax_len_r + 1) * D_RATIO)-2)? 1'b1:1'b0;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        burst_cntr <= 'd0;
    end
    else if (ctrl_idle) begin
        burst_cntr <= 'd0;
    end
    else if ((axi_wr_req_2 && h_wrdy && w_valid) || (ctrl_rd_req_2 && h_rdav)) begin
        burst_cntr <= burst_cntr + 1'd1;
    end
end
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        h_ctc_int <= 'd0;
    end
	else if (axi_wr_req_2 && h_pause) begin
        h_ctc_int <= 1'b1;
    end
	else if (ctrl_rd_req_2 && h_pause) begin
        h_ctc_int <= 1'b1;
    end
    else begin
        h_ctc_int <= 1'b0;
    end
end
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        h_wrdy_r  <= 2'b00;
        h_pause_r <= 3'h0;
        h_ctc     <= 1'b0;
    end
	else begin
        h_wrdy_r  <= {h_wrdy_r[0],h_wrdy};
        h_pause_r <= {h_pause_r[1:0],h_pause};
        h_ctc     <= h_ctc_int;
    end
end
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end



`timescale 100ps/10ps


// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(soft_iddio) #(
	parameter MODE = "RESYNC"     
) (
	input 		clk,
	input 	[7:0] 	ddr_din,
	output 	[7:0] 	ddr_din_HI,
	output 	[7:0] 	ddr_din_LO
);
reg [7:0] ddr_din_HI_reg;
reg [7:0] ddr_din_LO_reg;
reg [7:0] ddr_din_LO_resync;
always @ (posedge clk) ddr_din_HI_reg <=  ddr_din;
always @ (negedge clk) ddr_din_LO_reg <=  ddr_din;
assign ddr_din_HI = ddr_din_HI_reg;
generate
   if (MODE == "NORMAL") begin
      assign ddr_din_LO = ddr_din_LO_reg;
   end
   else if (MODE == "RESYNC") begin
      always @ (posedge clk) ddr_din_LO_resync <=  ddr_din_LO_reg;
      assign ddr_din_LO = ddr_din_LO_resync;
   end
   else begin 
      always @ (posedge clk) ddr_din_LO_resync <=  ddr_din_LO_reg;
      assign ddr_din_LO = ddr_din_LO_resync;
   end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_native_if) # (
    parameter USER_DBW          = 16,
    parameter USER_DMW          = USER_DBW / 8,
    parameter USER_WFD          = 256,
    parameter USER_RFD          = 256,
    parameter RAM_DBW           = 16,
    parameter RAM_ABW           = 32
)(
    input  wire                    user_clk,
    input  wire                    user_rst_n,
    input  wire                    ram_clk,
    input  wire                    ram_rst_n,
    input  wire                    user_ram_rdwr,
    input  wire                    user_ram_en,
    input  wire [USER_DBW-1:0]     user_wr_data,
    input  wire [(USER_DBW/8)-1:0] user_wr_datamask,
    input  wire [31:0]             user_wr_address,
    input  wire                    user_wr_en,
    input  wire [10:0]             user_wr_burst_len,
    output wire                    user_wr_buf_ready,
    output wire [USER_DBW-1:0]     user_rd_data,
    output wire                    user_rd_valid,
    output reg                     ctrl_idle,
    input  wire                    h_pause,
    input  wire                    h_ready,
    input  wire                    h_wrdy,
    output wire                    h_req,
    output wire [RAM_ABW-1:0]      h_addr,
    output wire [RAM_DBW*2-1:0]    h_wdata,
    output wire [RAM_DBW/4-1:0]    h_wdm,
    output wire                    h_ctc,
    output wire                    h_last,
    output wire                    h_btype,
    output wire                    h_atype,
    output wire                    h_rwen,
    input  wire                    h_mrdy,
    input  wire [RAM_DBW*2-1:0]    h_rdata,
    input  wire                    h_rdav
);
parameter IDLE       = 0,
          PRE_WR_OP  = 1,
          WR_INIT    = 2,
          WR_OP      = 3,
          DONE       = 4,
          RD_INIT    = 5,
          RD_OP      = 6;
localparam WR_WIDTH      = USER_DBW + USER_DMW;
localparam WR_GRP_RATIO  = USER_DBW/(RAM_DBW*2);
localparam U2C_TOTALW    = WR_WIDTH / WR_GRP_RATIO;
localparam DBW_GRP_WIDTH = USER_DBW / WR_GRP_RATIO;
localparam DBM_GRP_WIDTH = USER_DMW / WR_GRP_RATIO;
localparam WR_ASYM_RATIO = (USER_DBW/(RAM_DBW*2) == 16) ? 0 :
                           (USER_DBW/(RAM_DBW*2) == 8)  ? 1 :
                           (USER_DBW/(RAM_DBW*2) == 4)  ? 2 :
                           (USER_DBW/(RAM_DBW*2) == 2)  ? 3 : 4;
localparam RD_ASYM_RATIO = (USER_DBW/(RAM_DBW*2) == 16) ? 8 :
                           (USER_DBW/(RAM_DBW*2) == 8)  ? 7 :
                           (USER_DBW/(RAM_DBW*2) == 4)  ? 6 :
                           (USER_DBW/(RAM_DBW*2) == 2)  ? 5 : 4;
reg [3:0]  state;
reg [3:0]  next_state;
reg [11:0] wr_data_cnt;
reg        int_hram_idle;
reg        occupy_ctrl;
reg        op_done;
reg        wr_burst_en;
reg        r_native_empty_r;
reg		   rd_operation;
wire [WR_WIDTH-1:0]   wr_native_info;
wire                  fifo_rst;
wire                  wr_burst_completed;
wire                  w_data_full;
wire [U2C_TOTALW-1:0] rd_wdata;
wire [10:0]           h_burst_len;
wire [43:0]           native_control_data;
wire [43:0]           r_native_data;
wire                  native_control_rden;
wire                  op_done_sync;
wire                  ctrl_idle_sync;
wire                  r_native_empty;
wire                  ram_read_empty;
wire                  rd_wfifo;
assign fifo_rst    = ~(user_rst_n | ram_rst_n);
assign h_ctc       = 1'b0;
assign h_req       = occupy_ctrl;
assign h_wdm       = rd_wdata[U2C_TOTALW-1:RAM_DBW*2];
assign h_last      = wr_burst_completed;
assign h_btype     = r_native_data[31];
assign h_atype     = r_native_data[30];
assign h_addr      = r_native_data[RAM_ABW-1:0];
assign h_burst_len = r_native_data[42:32];
assign h_rwen      = r_native_data[43];
assign h_wdata     = wr_burst_en ? rd_wdata[RAM_DBW*2-1:0] : 'h0;
assign user_wr_buf_ready = ~w_data_full;
`IP_MODULE_NAME(efx_bit_sync) xop_done_sync    (.clk (user_clk), .rstn (user_rst_n), .din (op_done),   .dout (op_done_sync));
`IP_MODULE_NAME(efx_bit_sync) xctrl_idle_sync  (.clk (ram_clk),  .rstn (ram_rst_n),  .din (ctrl_idle), .dout (ctrl_idle_sync));
reg hold_ram_en;
always @ (posedge user_clk or negedge user_rst_n) begin
    if (~user_rst_n) begin
        hold_ram_en <= 1'b0;
    end
    else if (user_ram_en) begin
        hold_ram_en <= 1'b1;
    end
    else if (~op_done_sync) begin
        hold_ram_en <= 1'b0;
    end
end
always @ (posedge user_clk or negedge user_rst_n) begin
    if (~user_rst_n) begin
        ctrl_idle <= 1'b1;
    end
    else if (hold_ram_en & ~op_done_sync) begin
        ctrl_idle <= 1'b0;
    end
    else if (op_done_sync) begin
        ctrl_idle <= 1'b1;
    end
end
assign native_control_data = {user_ram_rdwr,user_wr_burst_len,user_wr_address};
assign native_control_rden = ~r_native_empty & int_hram_idle;
`IP_MODULE_NAME(efx_fifo_top) #(
    .SYNC_CLK           (0),
    .OUTPUT_REG         (0),
    .MODE               ("STANDARD"),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (4),
    .DATA_WIDTH         (44),
    .DEPTH              (4)
) user2ram_fifo (
    .a_rst_i        (fifo_rst),
    .wr_clk_i       (user_clk),
    .wr_en_i        (user_ram_en),
    .wdata          (native_control_data),
    .rd_clk_i       (ram_clk),
    .rd_en_i        (native_control_rden),
    .rdata          (r_native_data),
    .rd_valid_o     (),
    .empty_o        (r_native_empty)
);
genvar i;
generate
    for (i=0;i<WR_GRP_RATIO;i=i+1) begin
        assign wr_native_info[(U2C_TOTALW*i)+:U2C_TOTALW] = {~user_wr_datamask[(DBM_GRP_WIDTH*i)+:DBM_GRP_WIDTH],user_wr_data[(DBW_GRP_WIDTH*i)+:DBW_GRP_WIDTH]};
    end
endgenerate
assign rd_wfifo    = wr_burst_en & (wr_data_cnt <= h_burst_len-1);
wire rd_valid_debug;
`IP_MODULE_NAME(efx_fifo_top) #(
	.FAMILY 			("TITANIUM"),
    .SYNC_CLK           (0),
    .OUTPUT_REG         (0),
    .MODE               ("STANDARD"),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (WR_ASYM_RATIO),
    .DATA_WIDTH         (WR_WIDTH),
    .DEPTH              (USER_WFD)
) w_data_inst (
    .a_rst_i        (fifo_rst),
    .a_wr_rst_i     (1'b0),
    .a_rd_rst_i     (1'b0),
    .rst_busy       (),
    .clk_i          (1'b0),
    .wr_clk_i       (user_clk),
    .wr_en_i        (user_wr_en),
    .wdata          (wr_native_info),
    .rd_clk_i       (ram_clk),
    .rd_en_i        (rd_wfifo),
    .rdata          (rd_wdata),
    .rd_valid_o     (rd_valid_debug),
    .full_o         (w_data_full)
);
assign wr_rdfifo = h_mrdy & h_rdav & rd_operation & (wr_data_cnt <= h_burst_len-1); 
`IP_MODULE_NAME(efx_fifo_top) #(
	.FAMILY 			("TITANIUM"),
    .SYNC_CLK           (0),
    .OUTPUT_REG         (0),
    .MODE               ("STANDARD"),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (RD_ASYM_RATIO),
    .DATA_WIDTH         (RAM_DBW*2),
    .DEPTH              (USER_WFD)
) r_data_inst (
    .a_rst_i        (fifo_rst),
    .wr_clk_i       (ram_clk),
    .rd_clk_i       (user_clk),
    .wr_en_i        (wr_rdfifo),
    .wdata          (h_rdata),
    .rd_en_i        (~ram_read_empty),
    .rdata          (user_rd_data),
    .rd_valid_o     (user_rd_valid),
    .empty_o        (ram_read_empty)
);
assign wr_burst_completed = (wr_data_cnt == h_burst_len);
always @ (posedge ram_clk or negedge ram_rst_n) begin
    if (~ram_rst_n) begin
        wr_data_cnt <= 'd0;
    end
    else if (wr_burst_en | h_rdav) begin
        wr_data_cnt <= wr_data_cnt + 1'd1;
    end
    else begin
        wr_data_cnt <= 'd0;
    end
end
always @ (posedge ram_clk or negedge ram_rst_n) begin
    if (~ram_rst_n) begin
        state <= IDLE;
    end
    else begin
        state <= next_state;
    end
end
always @ (posedge ram_clk) begin
    r_native_empty_r <= ~r_native_empty;
end
always @ (*) begin
    case (state)
        IDLE    : begin if (r_native_empty_r && h_rwen) next_state = RD_INIT; else if (r_native_empty_r && ~h_rwen) next_state = WR_INIT; else next_state = IDLE;    end
        WR_INIT : begin if (h_wrdy)                     next_state = WR_OP;                                                               else next_state = WR_INIT; end
        WR_OP   : begin if (wr_burst_completed)         next_state = DONE;                                                                else next_state = WR_OP;   end
        RD_INIT : begin                                                                                                                        next_state = RD_OP;   end
        RD_OP   : begin if (wr_burst_completed)         next_state = DONE;                                                                else next_state = RD_OP;   end
        DONE    : begin if (ctrl_idle_sync)             next_state = IDLE;                                                                else next_state = DONE;    end
        default : begin                                                                                                                        next_state = IDLE;    end
    endcase
end
always @ (*) begin
    int_hram_idle = 1'b0;
    occupy_ctrl   = 1'b0;
    wr_burst_en   = 1'b0;
    rd_operation  = 1'b0;
    op_done       = 1'b0;
    case (state)
        IDLE    : begin int_hram_idle = 1'b1;                     end
        WR_INIT : begin occupy_ctrl   = 1'b1;                     end
        WR_OP   : begin occupy_ctrl   = 1'b1; wr_burst_en = 1'b1; end
        RD_INIT : begin occupy_ctrl   = 1'b1;                     end
        RD_OP	: begin rd_operation  = 1'b1; 					  end
        DONE    : begin op_done       = 1'b1;                     end
    endcase
end
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(mux_delay) (
        input           in      ,
        input   [2:0]   s       ,
	input           clk     ,
        output          out
   );
   reg    s_0, s_1, s_2, s_3, s_4, s_5, s_6;
   reg [6:0] s_reg;
   wire   i0_0, i0_1, i0_2, i0_3, i0_4, i0_5, i0_6, i0_7;
   wire   i1_0, i1_1, i1_2, i1_3, i1_4, i1_5, i1_6, i1_7;
   wire   o_0;
   wire   o_1;
   wire   o_2;
   wire   o_3;
   wire   o_4;
   wire   o_5;
   wire   o_6;
   wire   o_7;
   assign out = o_0;
   assign i0_0 = in;
   assign i0_1 = in;
   assign i0_2 = in;
   assign i0_3 = in;
   assign i0_4 = in;
   assign i0_5 = in;
   assign i0_6 = in;
   assign i0_7 = in;
   assign i1_0 = o_1;
   assign i1_1 = o_2;
   assign i1_2 = o_3;
   assign i1_3 = o_4;
   assign i1_4 = o_5;
   assign i1_5 = o_6;
   assign i1_6 = o_7;
   assign i1_7 = 1'b0;
   always @(*) begin
      case (s[2:0] )
        3'b000:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_0000;
        3'b001:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_0001;
        3'b010:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_0011;
        3'b011:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_0111;
        3'b100:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_1111;
        3'b101:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b001_1111;
        3'b110:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b011_1111;
        3'b111:  {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b111_1111;
        default: {s_6, s_5, s_4, s_3, s_2, s_1, s_0} = 7'b000_0000;
      endcase
   end
   always @(posedge clk)
     s_reg = {s_6, s_5, s_4, s_3, s_2, s_1, s_0};
   EFX_LUT4 # (
              .LUTMASK(16'hE4E4) 
             )
               MUX2TO1_inst0
             (
                .O      (o_0      ),
                .I0     (s_reg[0] ),
                .I1     (i0_0     ),
                .I2     (i1_0     ),
                .I3     (1'b1     )
             );
   EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst1
             (
                .O      (o_1      ),
                .I0     (s_reg[1] ),
                .I1     (i0_1     ),
                .I2     (i1_1     ),
                .I3     (1'b1     )
             );
   EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst2
             (
                .O      (o_2      ),
                .I0     (s_reg[2] ),
                .I1     (i0_2     ),
                .I2     (i1_2     ),
                .I3     (1'b1     )
             );
   EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst3
             (
                .O      (o_3      ),
                .I0     (s_reg[3] ),
                .I1     (i0_3     ),
                .I2     (i1_3     ),
                .I3     (1'b1     )
             );
    EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst4
             (
                .O      (o_4      ),
                .I0     (s_reg[4] ),
                .I1     (i0_4     ),
                .I2     (i1_4     ),
                .I3     (1'b1     )
             );
    EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst5
             (
                .O      (o_5      ),
                .I0     (s_reg[5] ),
                .I1     (i0_5     ),
                .I2     (i1_5     ),
                .I3     (1'b1     )
             );
    EFX_LUT4 # (
              .LUTMASK(16'hE4E4)
             )
               MUX2TO1_inst6
             (
                .O      (o_6      ),
                .I0     (s_reg[6] ),
                .I1     (i0_6     ),
                .I2     (i1_6     ),
                .I3     (1'b1     )
             );
    EFX_LUT4 # (
              .LUTMASK(16'hCCE4) 
             )
               MUX2TO1_inst7
             (
                .O      (o_7      ),
                .I0     (1'b1     ),
                .I1     (i0_7     ),
                .I2     (i1_7     ),
                .I3     (1'b1     )
             );
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end



`timescale 100ps/10ps


// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_cal_slv) #(
	parameter CAL_BYTES	 = 'h100,
	parameter RAM_DBW	 = 8,
	parameter RAM_ABW	 = 25,
	parameter RWDS_STEPS 	 = 8,
  	parameter DQ_STEPS 	 = 8,
  	parameter DQ_DLY_W 	 = 3,
  	parameter RWDS_DLY_W 	 = 3,
  	parameter CAL_MODE	= 2,
  	parameter DUAL_RAM	 = 1,
  	parameter RAM_DBW_CAL		= (DUAL_RAM == 1)? RAM_DBW*2 : RAM_DBW,
  	parameter INDIVI_DUAL_CAL = 1
) (
     input                      	clk,
     input                      	rst_n,
     output                     	cal_req,
     output                     	cal_last,
     output [RAM_ABW-1:0]          	cal_addr,
     output                     	cal_rwen,
     output [RAM_DBW_CAL*2-1:0]     cal_wdata,
     input                      	cal_wrdy, 
     input  [RAM_DBW_CAL*2-1:0]     cal_rdata,
     input                      	cal_rdav, 
     input                      	cal_en,
     output                     	cal_done,
     output                     	cal_fail,
     output [RWDS_DLY_W-1:0]    	cal_rwds_delay,
     output [RWDS_DLY_W-1:0]    	cal_rwds_delay_HI,
     output [RWDS_DLY_W-1:0]    	cal_rwds_delay_LO, 
     output [DQ_DLY_W*RAM_DBW-1:0]	cal_dq_delay,
     output [26:0]					cal_debug_info
);
function integer  partialsum_arith;
   input [31:0]   min_value;  
   input [31:0]   difference; 
   input [31:0]   index;      
   begin
      partialsum_arith = (index * (2*min_value + difference * (index - 1))) / 2;
   end
endfunction
localparam CAL_START	  	= 'h000000;
localparam CAL_END	  		= CAL_BYTES;
localparam CHECK_NUM 	  	= CAL_END-CAL_START;
localparam CHECK_CW 	  	= $clog2(CHECK_NUM+1);
localparam INIT		  		= 1'b0;
localparam CHECK	  		= 1'b1;
localparam SAMPLE_DATA 	  	= (DUAL_RAM == 1)? {RAM_DBW/8{16'h33cc,16'h6699, 16'h55aa, 16'hff00}} : {RAM_DBW/8{16'h55aa, 16'hff00}};
localparam SAMPLE_DATA_DUM  = {RAM_DBW/8{16'hcccc,16'h3399,16'h5500, 16'hfff1}};
localparam DQ_DLY_SUM_W   	= $clog2(partialsum_arith(0, 1, DQ_STEPS));
localparam DQ_DLY_CNT_W   	= $clog2(DQ_STEPS+1);
localparam RWDS_DLY_SUM_W 	= $clog2(partialsum_arith(0, 1, RWDS_STEPS));
localparam RWDS_DLY_CNT_W 	= $clog2(RWDS_STEPS+1);
reg 			  			cal_en_1r;
wire 			  			init_trig;
reg 			  			cal_state;
reg  [5:0] 		  			cal_done_delay;
reg  [CHECK_CW-1:0] 	  	check_cnt;
reg  [CHECK_CW-1:0] 	  	check_cnt_1r;
wire [RAM_DBW_CAL-1:0] 	  	dq_delay_count_pass;
reg  [RWDS_DLY_CNT_W-1:0] 	rwds_delay_count;
reg 			  			init_done;
wire 			  			init_cal_req;
wire 			  			init_cal_last;
wire 			  			init_cal_rwen;
reg 			  			check_trig;
reg  [RAM_DBW_CAL-1:0] 	  	check_error_bit;
wire 			  			check_error;
reg 			  			check_error_1r;
wire 			  			check_restart;
wire 			  			check_cal_req;
wire 			  			check_cal_last;
wire 			  			check_cal_rwen;
reg  [RWDS_DLY_W:0] 	  	check_rwds_delay;
reg  [DQ_DLY_W-1:0] 	  	check_dq_delaymax;
reg  [DQ_DLY_W-1:0] 	  	check_dq_delay [RAM_DBW-1:0];
reg  [RWDS_DLY_W:0] 	  	check_rwds_delay_HI;
reg  [RWDS_DLY_W:0] 	  	check_rwds_delay_LO;
wire 			  			adj_trig;
reg 			  			adj_flag;
reg  [6:0] 		  			adj_cnt;
reg 			  			check_fail;
reg 			  			check_done;
reg 			  			last_check;
reg  [DQ_DLY_W-1:0] 	  	error_dq_delaymax;
reg  [RWDS_DLY_W-1:0]	  	rwds_delay_ave;   
reg  			  			rwds_sel_start;   
reg 	     		  		rwds_sel_1r;
reg [3:0] rwds_count_final_HI;
reg [3:0] rwds_count_final_LO;
reg [3:0] rwds_delay_ave_HI;
reg [3:0] rwds_delay_ave_LO;
wire [RAM_DBW_CAL-1:0] 	  		dq_bit_pass;      
reg  [RWDS_DLY_SUM_W-1:0] 	rwds_delay_sum;   
reg 			  			rwds_pass_tog;    
reg 			  			rwds_delay_push;
reg 			  			data_tog;
reg 			  			data_compl_tog;
reg			  				step_passed;
reg [RWDS_STEPS-1:0]	  	step_passed_indicator;
reg [RWDS_STEPS-1:0] 		step_passed_indicator_LO;
reg [RWDS_STEPS-1:0] 		step_passed_indicator_HI;
reg			  				cal_done_reg;
reg			  				cal_pass_reg;
reg [RWDS_DLY_W-1:0]	  	locked_rwds_delay;
reg [RWDS_DLY_W-1:0]	  	locked_rwds_delay_HI;
reg [RWDS_DLY_W-1:0]	  	locked_rwds_delay_LO;
reg [3:0] 				rwds_count_temp;
reg [3:0] 				rwds_count_final;
reg 					pass_push;
reg [4:0] 				window_counter;
reg [RWDS_DLY_SUM_W-1:0] rwds_delay_sum_new;
reg [RWDS_DLY_SUM_W-1:0] rwds_delay_sum_temp;
reg [3:0] 				rwds_delay_ave_new;
reg [5:0] 				req_cntr;
reg						req_cntr_hit;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          cal_en_1r <=  1'b0;
     end
     else begin
          cal_en_1r <=  cal_en;
     end
end
assign init_trig = ~cal_en_1r & cal_en;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          cal_state <=  INIT;
     end
     else if (init_trig)
          cal_state <=  INIT;
     else if (init_done) begin
          cal_state <=  CHECK;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          check_cnt <=  'd0;
          data_tog <= 1'b0;
          data_compl_tog <= 1'b0;
     end
     else if (init_trig | init_done | check_restart) begin
          check_cnt <=  'd0;
          data_tog <= 1'b0;
          data_compl_tog <= 1'b0;
     end
     else if (cal_wrdy) begin
         if (cal_state == INIT) begin
         	 check_cnt <=  check_cnt + (check_cnt<CHECK_NUM);
         	 data_tog <= ~data_tog;
         	 if (data_tog) begin
         	 	 data_compl_tog <= ~data_compl_tog;
         	 end
         end
     end
     else if (cal_rdav || req_cntr_hit)begin
          if (cal_state == CHECK) begin
               check_cnt <=  check_cnt + (check_cnt<CHECK_NUM);
               data_tog <= ~data_tog;
               if (data_tog) begin
               	   data_compl_tog <= ~data_compl_tog;
               end
          end
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
         req_cntr <=  6'b0;
         req_cntr_hit <= 1'b0;
     end
     else if (cal_last) begin
     	 req_cntr 		<= 6'b0;
     	 req_cntr_hit 	<= 1'b0;
     end
     else if (req_cntr == 'd39) begin
     	 req_cntr 		<= req_cntr;
		 req_cntr_hit 	<= 1'b1;
     end
     else if (check_cnt == 0) begin
         req_cntr <= req_cntr + 1;
     end
end
assign cal_addr  = CAL_START;
assign cal_req   = (cal_state==INIT)? init_cal_req  : check_cal_req;
assign cal_last  = (cal_state==INIT)? init_cal_last : check_cal_last;
assign cal_rwen  = (cal_state==INIT)? init_cal_rwen : check_cal_rwen; 
assign cal_wdata = {RAM_DBW_CAL*2{data_compl_tog}} ^ ( data_tog ?  SAMPLE_DATA[RAM_DBW_CAL*2 +: RAM_DBW_CAL*2] : SAMPLE_DATA[0 +: RAM_DBW_CAL*2]);
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          cal_done_delay <=  6'h00;
     end
     else if (init_trig | check_restart) begin
          cal_done_delay <=  6'h00;
     end
     else if (cal_done_delay != 6'h3f) begin
          cal_done_delay <=  cal_done_delay + check_done;
     end
end
assign cal_done = cal_done_delay[5]; 
assign cal_fail = check_fail;
assign cal_rwds_delay = check_rwds_delay[2:0];
generate
if (INDIVI_DUAL_CAL == 1) begin
	assign cal_rwds_delay_HI = check_rwds_delay_HI[2:0];
	assign cal_rwds_delay_LO = check_rwds_delay_LO[2:0];
end
endgenerate
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
          init_done <=  1'b0;
     end
     else begin
          init_done <=  (cal_state==INIT) && (check_cnt==CHECK_NUM-2);
     end
end
assign init_cal_req = init_trig;
assign init_cal_last = init_done;
assign init_cal_rwen = 1'b0;
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
         check_trig <=  1'b0;
     end
     else begin
         check_trig <=  init_done | check_restart;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
         check_done <= 1'b0;
     end
     else if (last_check) begin
     	 check_done <= 1'b1;
     end
end
assign check_cal_req  = check_trig;
assign check_cal_last = adj_trig;
assign check_cal_rwen = 1'b1;
always @ (posedge clk or negedge rst_n)
begin
      if (!rst_n) begin
      	  error_dq_delaymax <= {DQ_DLY_W{1'b0}};
      end
      else if (cal_state==CHECK) begin
		  if (check_restart | (check_cnt==CHECK_NUM)) begin
			  error_dq_delaymax <= check_dq_delaymax;
		  end
      end
end
	reg  [RAM_DBW-1:0] 	  		check_error_bit_HI;
	reg  [RAM_DBW-1:0] 	  		check_error_bit_LO;
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	genvar j;
   for (j=0; j<RAM_DBW; j=j+1) begin
	 always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			 check_error_bit_HI[j] <=  1'b0;
			 check_error_bit_LO[j] <=  1'b0;
		end
		else if (cal_state==CHECK) begin
			if (check_restart|(check_cnt==CHECK_NUM)) begin
				check_error_bit_HI[j] <=  1'b0;
				check_error_bit_LO[j] <= 1'b0;
			end
			else if ((cal_rdav || req_cntr_hit) && (check_cnt<CHECK_NUM))begin
				if (error_dq_delaymax == check_dq_delaymax) begin
					if (data_tog) begin 
						check_error_bit_HI[j] <=  ~({cal_rdata[j+RAM_DBW*3],cal_rdata[j+RAM_DBW*2]} == ({2{data_compl_tog}} ^ {SAMPLE_DATA[j+(RAM_DBW*3)],SAMPLE_DATA[j+(RAM_DBW*2)]}));
					end
					else begin 
						check_error_bit_LO[j] <=  ~({cal_rdata[j+RAM_DBW],cal_rdata[j]} == ({2{data_compl_tog}} ^ {SAMPLE_DATA[j+RAM_DBW],SAMPLE_DATA[j]}));
					end
				end
			end
		end
	 end
   end
end
else begin
   genvar j;
   for (j=0; j<RAM_DBW_CAL; j=j+1) begin
	 always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			 check_error_bit[j] <=  1'b0;
		end
		else if (cal_state==CHECK) begin
			if (check_restart|(check_cnt==CHECK_NUM)) begin
				check_error_bit[j] <=  1'b0;
			end
			else if ((cal_rdav || req_cntr_hit) && (check_cnt<CHECK_NUM))begin
				if (error_dq_delaymax == check_dq_delaymax) begin
					if (data_tog) begin 
						check_error_bit[j] <=  ~({cal_rdata[j+RAM_DBW_CAL],cal_rdata[j]} == ({2{data_compl_tog}} ^ {SAMPLE_DATA[j+(RAM_DBW_CAL*3)],SAMPLE_DATA[j+(RAM_DBW_CAL*2)]}));
					end
					else begin
						check_error_bit[j] <=  ~({cal_rdata[j+RAM_DBW_CAL],cal_rdata[j]} == ({2{data_compl_tog}} ^ {SAMPLE_DATA[j+RAM_DBW_CAL],SAMPLE_DATA[j]}));
					end
				end
			end
		end
	 end
   end
end
endgenerate
always @ (posedge clk or negedge rst_n)
begin
      if (!rst_n) begin
      	  check_cnt_1r <= 'd0;
      end
      else begin
      	  check_cnt_1r <= check_cnt;
      end
end
assign check_error = (check_cnt==CHECK_NUM) && (cal_state == CHECK);
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          check_error_1r <=  1'b0;
     end
     else begin
          check_error_1r <=   check_error;
     end
end
assign adj_trig = ~check_error_1r & check_error;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          adj_flag<=  1'b0;
     end
     else if (adj_trig) begin
          adj_flag <=  1'b1;
     end
     else if (adj_cnt== 'd127) begin
          adj_flag <=  1'b0;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          adj_cnt <=  'd0;
     end
     else if ((cal_state==CHECK)) begin
          if (!adj_flag) begin
               adj_cnt <=  'd0;
          end
          else if (adj_flag) begin
               adj_cnt <=  adj_cnt + 1'b1;
          end
     end
end
assign check_restart = (adj_cnt == 'd126) & ~last_check;
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always @ (posedge clk or negedge rst_n) begin 
		 if (!rst_n) begin
			  check_rwds_delay_HI <=   {(RWDS_DLY_W+1){1'b0}};
			  check_rwds_delay_LO <=   {(RWDS_DLY_W+1){1'b0}};
			  rwds_sel_start <= 1'b0;
			  rwds_sel_1r <= 1'b0;
		 end
		 else if (init_trig) begin
			  check_rwds_delay_HI <=   {(RWDS_DLY_W+1){1'b0}};
			  check_rwds_delay_LO <=   {(RWDS_DLY_W+1){1'b0}};
			  rwds_sel_start <= 1'b0;
			  rwds_sel_1r <= 1'b0;
		 end
		 else if (last_check & ~cal_done) begin 
			if (adj_cnt[6:2] != {5{1'b0}}) begin
			   if (~rwds_sel_start && window_counter == 'd17) begin
				  rwds_sel_start <= 1'b1;
				  if (rwds_delay_ave_HI > 7) begin
					  check_rwds_delay_HI <= rwds_delay_ave_HI - 'd8; 
				  end
				  else begin
					  check_rwds_delay_HI <= rwds_delay_ave_HI;
				  end
				  if (rwds_delay_ave_LO > 7) begin
					  check_rwds_delay_LO <= rwds_delay_ave_LO - 'd8; 
				  end
				  else begin
					  check_rwds_delay_LO <= rwds_delay_ave_LO;
				  end
			   end
			   else if (~rwds_sel_1r) begin
				  check_rwds_delay_HI <= check_rwds_delay_HI;
				  check_rwds_delay_LO <= check_rwds_delay_LO;
			   end
			   rwds_sel_1r <= ~rwds_sel_1r;
			end
		 end
		 else if ((adj_cnt == 'd1)&(check_rwds_delay_HI != RWDS_STEPS-1) &(check_rwds_delay_LO != RWDS_STEPS-1)) begin
			 if (check_dq_delaymax == DQ_STEPS-1) begin
				 check_rwds_delay_HI <=  check_rwds_delay_HI + 1'b1;
				 check_rwds_delay_LO <=  check_rwds_delay_LO + 1'b1;
			 end
		 end
	end
end
else begin
	always @ (posedge clk or negedge rst_n) begin 
		 if (!rst_n) begin
			  check_rwds_delay <=   {RWDS_DLY_W{1'b0}};
			  rwds_sel_start <= 1'b0;
			  rwds_sel_1r <= 1'b0;
		 end
		 else if (init_trig) begin
			  check_rwds_delay <=   {RWDS_DLY_W{1'b0}};
			  rwds_sel_start <= 1'b0;
			  rwds_sel_1r <= 1'b0;
		 end
		 else if (last_check & ~cal_done) begin 
			if (adj_cnt[6:2] != {5{1'b0}}) begin
			   if (~rwds_sel_start && window_counter == 'd17) begin
				  rwds_sel_start <= 1'b1;
				  if (rwds_delay_ave_new > 7) begin
					  check_rwds_delay <= rwds_delay_ave_new - 'd8; 
				  end
				  else begin
					  check_rwds_delay <= rwds_delay_ave_new;
				  end
			   end
			   else if (~rwds_sel_1r) begin
				  check_rwds_delay <= check_rwds_delay;
			   end
			   rwds_sel_1r <= ~rwds_sel_1r;
			end
		 end
		 else if ((adj_cnt == 'd1)&(check_rwds_delay != RWDS_STEPS-1)) begin
			 if (check_dq_delaymax == DQ_STEPS-1) 
				 check_rwds_delay <=  check_rwds_delay + 1'b1;
		 end
	end
end
endgenerate
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always @ (posedge clk or negedge rst_n) begin
		  if (!rst_n) begin
			   check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
		  else if (init_trig)begin
			   check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
		  else if (adj_cnt == 'd1) begin
			 if (check_dq_delaymax != DQ_STEPS-1)
				 check_dq_delaymax <= check_dq_delaymax + 1'b1;
			 else if ((check_rwds_delay_HI != RWDS_STEPS-1) &&  (check_rwds_delay_LO != RWDS_STEPS-1))
				 check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
	end
end
else begin
	always @ (posedge clk or negedge rst_n) begin
		  if (!rst_n) begin
			   check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
		  else if (init_trig)begin
			   check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
		  else if (adj_cnt == 'd1) begin
			 if (check_dq_delaymax != DQ_STEPS-1)
				 check_dq_delaymax <= check_dq_delaymax + 1'b1;
			 else if (check_rwds_delay != RWDS_STEPS-1)
				 check_dq_delaymax <= {DQ_DLY_W{1'b0}};
		  end
    end
end
endgenerate
reg 	[RAM_DBW_CAL-1:0] dq_bit_err;
reg 	[RAM_DBW-1:0] dq_bit_err_HI;
reg 	[RAM_DBW-1:0] dq_bit_err_LO;
generate
	if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
		genvar k;
	   for (k=0; k<RAM_DBW; k=k+1) begin
		  assign dq_bit_pass[k+RAM_DBW] 	= ~dq_bit_err_HI[k] ;
		  assign dq_bit_pass[k] 			= ~dq_bit_err_LO[k] ;
		  always @ (posedge clk or negedge rst_n) begin
				if (!rst_n) begin
					dq_bit_err_HI[k] 	<= 1'b0;
				end
				else if (init_trig) begin
					dq_bit_err_HI[k] 	<= 1'b0;
				end
				else begin
					if (check_restart) begin
						dq_bit_err_HI[k] <= 1'b0;
					end
					else begin
						case (check_error_bit_HI[k])
					   	   1'b0: dq_bit_err_HI[k] <= dq_bit_err_HI[k];
					   	   default : dq_bit_err_HI[k] <= 1'b1;
					   	endcase
					end
				end
		  end
		  always @ (posedge clk or negedge rst_n) begin
				if (!rst_n) begin
					dq_bit_err_LO[k] 	<= 1'b0;
				end
				else if (init_trig) begin
					dq_bit_err_LO[k] 	<= 1'b0;
				end
				else begin
					if (check_restart) begin
					   dq_bit_err_LO[k] <= 1'b0;
					end
					else begin
					   case (check_error_bit_LO[k])
					   	   1'b0: dq_bit_err_LO[k] <= dq_bit_err_LO[k];
					   	   default : dq_bit_err_LO[k] <= 1'b1;
					   endcase
					end
				end
		  end
	   end
	end
	else if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 0) begin
		reg 	[RAM_DBW_CAL-1:0] dq_bit_err;
		genvar k;
	   for (k=0; k<RAM_DBW_CAL; k=k+1) begin
		  assign dq_bit_pass[k] = ~dq_bit_err[k] ;
		  always @ (posedge clk or negedge rst_n) begin
				 if (!rst_n) begin
					dq_bit_err[k] 	<= 1'b0;
				 end
				 else if (init_trig) begin
					dq_bit_err[k] 	<= 1'b0;
				 end
				 else begin
					if (check_restart) begin
					   dq_bit_err[k] <= 1'b0;
					end
					else begin
					   case (check_error_bit[k])
					   	   1'b0: dq_bit_err[k] <= dq_bit_err[k];
					   	   default : dq_bit_err[k] <= 1'b1;
					   endcase
					end
				end
		  end
	   end
	end
	else begin
	   genvar k;
	   for (k=0; k<RAM_DBW; k=k+1) begin
		  reg [DQ_DLY_W-1:0] 			dq_delay_temp;      
		  reg [DQ_DLY_SUM_W-1:0] 		dq_delay_sum;  	    
		  reg 							dq_bit_err;         
		  reg 							dq_bit_pass_tog;    
		  reg [DQ_DLY_CNT_W-1:0] 		dq_delay_count;	    
		  reg [(DQ_DLY_W*RAM_DBW)-1:0] 	dq_delay_ave_rwds;  
		  reg 							dq_delay_push;
		  assign dq_bit_pass[k] = ~dq_bit_err & ~dq_bit_pass_tog;
		  assign dq_delay_count_pass[k] = (dq_delay_count != {DQ_DLY_CNT_W{1'b0}});
		  always @ (posedge clk or negedge rst_n) begin
			 if (!rst_n) begin
				dq_delay_temp 	<= {DQ_DLY_W{1'b0}};
				dq_delay_sum 	<= {DQ_DLY_SUM_W{1'b0}};
				dq_bit_err 		<= 1'b0;
				dq_bit_pass_tog 	<= 1'b0;
				dq_delay_count 	<= {DQ_DLY_CNT_W{1'b0}};
				dq_delay_ave_rwds	<= {DQ_DLY_W*RAM_DBW{1'b0}};
				dq_delay_push 	<= 1'b0;
			 end
			 else if (init_trig) begin
				dq_delay_temp 	<= {DQ_DLY_W{1'b0}};
				dq_delay_sum 	<= {DQ_DLY_SUM_W{1'b0}};
				dq_bit_err 		<= 1'b0;
				dq_bit_pass_tog 	<= 1'b0;
				dq_delay_count 	<= {DQ_DLY_CNT_W{1'b0}};
				dq_delay_ave_rwds 	<= {DQ_DLY_W*RAM_DBW{1'b0}};
				dq_delay_push 	<= 1'b0;
			 end
			 else begin
				if (check_restart) begin
				   dq_bit_err <= 1'b0;
				end
				else begin 
				   case (check_error_bit[k])
					   1'b0: dq_bit_err <= dq_bit_err;
					   default : dq_bit_err <= 1'b1;
					endcase
				end
				if (adj_cnt == 'd1) begin 
				   if (check_dq_delaymax != DQ_STEPS-1) begin
					   dq_delay_temp <= dq_delay_temp + 1'b1;
				   end
				   else if (check_rwds_delay != RWDS_STEPS-1) begin
					   dq_delay_temp <= {DQ_DLY_W{1'b0}};
				   end
				   if ((check_dq_delaymax == DQ_STEPS-1) & (check_rwds_delay != RWDS_STEPS-1)) begin
					  dq_delay_sum <= {DQ_DLY_SUM_W{1'b0}};
					  dq_delay_count <= {DQ_DLY_CNT_W{1'b0}};
					  dq_bit_pass_tog <= 1'b0;
					  dq_delay_push <= 1'b0;
				   end
				   else if (dq_bit_pass[k]) begin
					  dq_delay_push <= 1'b1;
					  if (~dq_delay_push) begin
						 dq_delay_sum <= check_dq_delaymax;
					  end
					  dq_delay_count <= dq_delay_count + 1'b1; 
				   end
				   else if (dq_delay_count != {DQ_DLY_CNT_W{1'b0}}) begin
					   dq_bit_pass_tog <= 1'b1;
				   end
				   if (check_dq_delaymax == DQ_STEPS-1) begin
					   if (dq_bit_pass[k]) begin
						   if (dq_delay_count != {DQ_DLY_CNT_W{1'b0}}) begin
							   dq_delay_ave_rwds[(check_rwds_delay*DQ_DLY_W)+:DQ_DLY_W] <= dq_delay_sum + (dq_delay_count >> 1);
						   end
						   else begin
							   dq_delay_ave_rwds[(check_rwds_delay*DQ_DLY_W)+:DQ_DLY_W] <= check_dq_delaymax;
						   end
					   end
					   else if (dq_delay_count != {DQ_DLY_CNT_W{1'b0}}) begin
						   dq_delay_ave_rwds[(check_rwds_delay*DQ_DLY_W)+:DQ_DLY_W] <= dq_delay_sum + ((dq_delay_count - 1'b1) >> 1);
					   end
				   end
				end
			 end
		  end
		  always @ (posedge clk or negedge rst_n) begin
			 if (!rst_n) begin
				check_dq_delay[k] <= {DQ_DLY_W{1'b0}};
			 end
			 else if (init_trig) begin
				check_dq_delay[k] <= {DQ_DLY_W{1'b0}};
			 end
			 else if (~last_check) begin
				check_dq_delay[k] <= dq_delay_temp;
			 end
			 else if ((adj_cnt[6:1] != {6{1'b0}}) & ~cal_done) begin
				check_dq_delay[k] <= dq_delay_ave_rwds[(check_rwds_delay*DQ_DLY_W)+:DQ_DLY_W];
			 end
		  end
		  assign cal_dq_delay[k*DQ_DLY_W+(DQ_DLY_W-1) -: DQ_DLY_W]  = check_dq_delay[k];
	end
   end
endgenerate
generate
if (INDIVI_DUAL_CAL == 0) begin
always @ (posedge clk or negedge rst_n)
begin
      if (!rst_n) begin
		   rwds_delay_sum <= {RWDS_DLY_SUM_W{1'b0}};
		   rwds_delay_count <= {RWDS_DLY_CNT_W{1'b0}};
		   rwds_pass_tog <= 1'b0;
		   rwds_delay_push <= 1'b0;
      end
      else if (init_trig) begin
		   rwds_delay_sum <= {RWDS_DLY_SUM_W{1'b0}};
		   rwds_delay_count <= {RWDS_DLY_CNT_W{1'b0}};
		   rwds_pass_tog <= 1'b0;
		   rwds_delay_push <= 1'b0;
      end
      else if (adj_cnt == 'd1) begin
		 if (check_dq_delaymax == DQ_STEPS-1) begin 
			if (((dq_bit_pass == {RAM_DBW_CAL{1'b1}}) | (dq_delay_count_pass == {RAM_DBW_CAL{1'b1}})) & ~rwds_pass_tog) begin
				rwds_delay_push <= 1'b1;
			   if (~rwds_delay_push) begin
				   rwds_delay_sum <= check_rwds_delay;
			   end
			   rwds_delay_count <= rwds_delay_count + 1'b1;
			end
			else if (rwds_delay_count != {RWDS_DLY_CNT_W{1'b0}}) begin 
			   rwds_pass_tog <= 1'b1; 
			end
			if (check_rwds_delay == RWDS_STEPS-1) begin 
			   if (((dq_bit_pass == {RAM_DBW_CAL{1'b1}}) | (dq_delay_count_pass == {RAM_DBW_CAL{1'b1}})) & ~rwds_pass_tog) begin
				   if (rwds_delay_count != {RWDS_DLY_CNT_W{1'b0}}) begin  
					   rwds_delay_ave <= rwds_delay_sum + (rwds_delay_count >> 1);
				   end
				   else begin
					   rwds_delay_ave <= check_rwds_delay;
				   end
			   end
			   else if (rwds_delay_count != {RWDS_DLY_CNT_W{1'b0}}) begin 
				   rwds_delay_ave <= rwds_delay_sum + ((rwds_delay_count) >> 1);
			   end
			end
		end
	end
end
end
endgenerate
reg 			calc_start;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        calc_start <= 1'b0;
    end else begin
        calc_start <= check_done;
    end
end
	wire [15:0] 	step_pass_combine_HI;
	wire [15:0] 	step_pass_combine_LO;
	reg  [15:0] 	step_pass_combine_HI_r;
	reg  [15:0] 	step_pass_combine_LO_r;
	reg [3:0] 	rwds_count_temp_HI;
	reg [3:0]	rwds_count_temp_LO;
	reg [2:0] 	rwds_delay_sum_HI;
	reg [2:0] 	rwds_delay_sum_LO;
	reg [2:0] 	rwds_delay_sum_temp_HI;
	reg [2:0] 	rwds_delay_sum_temp_LO;
	reg 		pass_push_HI;
	reg 		pass_push_LO;
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	assign step_pass_combine_HI = {step_passed_indicator_HI,step_passed_indicator_HI};
	assign step_pass_combine_LO = {step_passed_indicator_LO,step_passed_indicator_LO};
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			step_pass_combine_HI_r <= 0;
			step_pass_combine_LO_r <= 0;
		end
		else if (calc_start && adj_cnt == 'd4) begin
			step_pass_combine_HI_r <= step_pass_combine_HI;
			step_pass_combine_LO_r <= step_pass_combine_LO;
		end
		else if (calc_start && (adj_cnt[6:3] != 4'b0)) begin
			step_pass_combine_HI_r <= step_pass_combine_HI_r >> 1;
			step_pass_combine_LO_r <= step_pass_combine_LO_r >> 1;
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			rwds_count_temp_HI		<= 'b0;
			rwds_count_temp_LO		<= 'b0;
			pass_push_HI 			<= 'b0;
			pass_push_LO 			<= 'b0;
			rwds_delay_sum_temp_HI 		<= 'b0;
			rwds_delay_sum_temp_LO		<= 'b0;
		end
		else if (adj_cnt[6:3] != 4'b0) begin 
			if (step_pass_combine_HI_r[0]) begin 
				rwds_count_temp_HI 	<= rwds_count_temp_HI + 1'b1;
				if (!pass_push_HI) begin
					rwds_delay_sum_temp_HI 	<= window_counter[3:0];
					pass_push_HI 			<= 1'b1;
				end
			end
			else if (!step_pass_combine_HI_r[0]) begin
				rwds_count_temp_HI 		<= 'b0;
				pass_push_HI 			<= 'b0;
			end
			if (step_pass_combine_LO_r[0]) begin 
				rwds_count_temp_LO 	<= rwds_count_temp_LO + 1'b1;
				if (!pass_push_LO) begin
					rwds_delay_sum_temp_LO 	<= window_counter[3:0];
					pass_push_LO 			<= 1'b1;
				end
			end
			else if (!step_pass_combine_LO_r[0]) begin
				rwds_count_temp_LO 		<= 'b0;
				pass_push_LO 			<= 1'b0;
			end
		end
	end
	always @ (posedge clk or negedge rst_n) begin 
		if (!rst_n) begin
			rwds_count_final_HI		<= 'b0;
			rwds_delay_sum_HI 		<= rwds_delay_sum_temp_HI;
		end
		else if ((rwds_count_temp_HI > rwds_count_final_HI) && calc_start) begin
			rwds_count_final_HI 	<= rwds_count_temp_HI;
			rwds_delay_sum_HI 		<= rwds_delay_sum_temp_HI;
		end
	end
	always @ (posedge clk or negedge rst_n) begin 
		if (!rst_n) begin
			rwds_count_final_LO		<= 'b0;
			rwds_delay_sum_LO 		<= 'b0;
		end
		else if ((rwds_count_temp_LO > rwds_count_final_LO) && calc_start) begin
			rwds_count_final_LO 	<= rwds_count_temp_LO;
			rwds_delay_sum_LO 		<= rwds_delay_sum_temp_LO;
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			rwds_delay_ave_HI <= 'b0;
		end
		else if (window_counter == 'd16) begin
			rwds_delay_ave_HI <= rwds_delay_sum_HI + (rwds_count_final_HI >> 1);
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			rwds_delay_ave_LO <= 'b0;
		end
		else if (window_counter == 'd16) begin
			rwds_delay_ave_LO <= rwds_delay_sum_LO + (rwds_count_final_LO >> 1);
		end
	end
end
else begin 
	wire [15:0] 	step_pass_combine;
	reg  [15:0] 	step_pass_combine_r;
	assign step_pass_combine = {step_passed_indicator,step_passed_indicator};
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			step_pass_combine_r <= 'd0;
		end
		else if (calc_start && adj_cnt == 'd4) begin
			step_pass_combine_r <= step_pass_combine;
		end
		else if (calc_start && (adj_cnt[6:3] != 4'b0)) begin
			step_pass_combine_r <= step_pass_combine_r >> 1;
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			rwds_count_temp		<= 'b0;
			pass_push 			<= 1'b0;
			rwds_delay_sum_temp 	<= 'b0;
		end
		else if (adj_cnt[6:3] != 4'b0) begin 
			if (step_pass_combine_r[0]) begin 
				rwds_count_temp 	<= rwds_count_temp + 1'b1;
				if (!pass_push) begin
					rwds_delay_sum_temp 	<= window_counter;
					pass_push 			<= 1'b1;
				end
			end
			else if (!step_pass_combine_r[0]) begin
				rwds_count_temp 	<= 'b0;
				pass_push 			<= 1'b0;
			end
		end
	end
	always @ (posedge clk or negedge rst_n) begin 
		if (!rst_n) begin
			rwds_count_final	<= 'b0;
			rwds_delay_sum_new 	<= 'b0;
		end
		else if ((rwds_count_temp > rwds_count_final) && calc_start) begin
			rwds_count_final 	<= rwds_count_temp;
			rwds_delay_sum_new 	<= rwds_delay_sum_temp;
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			rwds_delay_ave_new <= 'b0;
		end
		else if (window_counter == 'd16) begin
			rwds_delay_ave_new <= rwds_delay_sum_new + (rwds_count_final >> 1);
		end
	end
end
endgenerate
always @ (posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		window_counter <= 0;
	end
	else if (calc_start && (adj_cnt[6:3] != 4'b0) && window_counter !=5'b11111) begin
		window_counter <= window_counter + 1'b1;
	end
end
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always @ (posedge clk or negedge rst_n) begin
		  if (!rst_n) begin
			  last_check <= 1'b0;
		  end
		  else if (init_trig)begin
			  last_check <= 1'b0;
		  end
		  else if (((check_rwds_delay_HI=='d7)|(check_rwds_delay_LO=='d7)) & (adj_cnt == 'd1) & (check_dq_delaymax==DQ_STEPS-1)) begin
			  last_check <= 1'b1;
		  end
    end
	always @ (posedge clk or negedge rst_n) begin
		 if (!rst_n) begin
			  check_fail <=   1'b0;
		 end
		 else if (init_trig)begin
			  check_fail <=  1'b0;
		 end
		 else if(last_check & ((step_passed_indicator_HI == 8'b0) || (step_passed_indicator_LO == 8'b0))) begin
			  check_fail <=   1'b1;
		 end
	end
end
else begin
	always @ (posedge clk or negedge rst_n) begin
		  if (!rst_n) begin
			  last_check <= 1'b0;
		  end
		  else if (init_trig)begin
			  last_check <= 1'b0;
		  end
		  else if ((check_rwds_delay==RWDS_STEPS-1) & (adj_cnt == 'd1) & (check_dq_delaymax==DQ_STEPS-1)) begin
			  last_check <= 1'b1;
		  end
    end
	always @ (posedge clk or negedge rst_n) begin
		 if (!rst_n) begin
			  check_fail <=   1'b0;
		 end
		 else if (init_trig)begin
			  check_fail <=  1'b0;
		 end
		 else if(last_check & (rwds_delay_count == {RWDS_DLY_CNT_W{1'b0}})) begin
			  check_fail <=   1'b1;
		 end
	end
end
endgenerate
reg step_passed_HI;
reg step_passed_LO;
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always @ (posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed_HI <= 1'b0;
		end
		else begin
			if(check_cal_last && dq_bit_pass[RAM_DBW_CAL-1:RAM_DBW] == {RAM_DBW{1'b1}} && check_dq_delaymax == {DQ_DLY_W{1'b1}})
				step_passed_HI <= 1'b1;
			else
				step_passed_HI <= 1'b0;
		end
	end
	always @ (posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed_LO <= 1'b0;
		end
		else begin
			if(check_cal_last && dq_bit_pass[RAM_DBW-1:0] == {RAM_DBW{1'b1}} && check_dq_delaymax == {DQ_DLY_W{1'b1}})
				step_passed_LO <= 1'b1;
			else
				step_passed_LO <= 1'b0;
		end
	end
end
else begin
	always @ (posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed <= 1'b0;
		end
		else begin
			if(check_cal_last && dq_bit_pass == {RAM_DBW_CAL{1'b1}} && check_dq_delaymax == {DQ_DLY_W{1'b1}})
				step_passed <= 1'b1;
			else
				step_passed <= 1'b0;
		end
	end
end
endgenerate
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	genvar p;
	for (p=0; p<RWDS_STEPS; p=p+1) begin
	always @(posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed_indicator_HI[p] <= 1'b0;
		end
		else begin
			if(step_passed_HI && check_rwds_delay_HI == p)
				step_passed_indicator_HI[p] <= 1'b1;
			else
				step_passed_indicator_HI[p] <= step_passed_indicator_HI[p];
		end
	end
	always @(posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed_indicator_LO[p] <= 1'b0;
		end
		else begin
			if(step_passed_LO && check_rwds_delay_LO == p)
				step_passed_indicator_LO[p] <= 1'b1;
			else
				step_passed_indicator_LO[p] <= step_passed_indicator_LO[p];
		end
	end
	end
end
else begin
   genvar p;
	for (p=0; p<RWDS_STEPS; p=p+1) begin
	always @(posedge clk or negedge rst_n) begin
		if(!rst_n) begin
			step_passed_indicator[p] <= 1'b0;
		end
		else begin
			if(step_passed && check_rwds_delay == p)
				step_passed_indicator[p] <= 1'b1;
			else
				step_passed_indicator[p] <= step_passed_indicator[p];
		end
	end
	end
end
endgenerate
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cal_done_reg <= 1'b0;
	end
	else begin
		cal_done_reg <= cal_done;
	end
end
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			locked_rwds_delay_HI <= 'b0;
		end
		else if(cal_done_reg) begin
			locked_rwds_delay_HI  <= cal_rwds_delay_HI;
		end
		else begin
			locked_rwds_delay_HI <= locked_rwds_delay_HI;
		end
	end
	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			locked_rwds_delay_LO <= 'b0;
		end
		else if(cal_done_reg) begin
			locked_rwds_delay_LO  <= cal_rwds_delay_LO;
		end
		else begin
			locked_rwds_delay_LO <= locked_rwds_delay_LO;
		end
	end
	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			cal_pass_reg <= 'b0;
		end
		else if(cal_done_reg && (step_passed_indicator_HI != {RWDS_STEPS{1'b0}} || step_passed_indicator_LO != {RWDS_STEPS{1'b0}})) begin
			cal_pass_reg <= ~cal_fail;
		end
		else begin
			cal_pass_reg <= cal_pass_reg;
		end
	end
	assign cal_debug_info = {step_passed_indicator_HI,  locked_rwds_delay_HI, step_passed_indicator_LO, locked_rwds_delay_LO, 3'b000, cal_pass_reg, cal_done_reg};
end
else begin
	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			cal_pass_reg 		<= 'b0;
			locked_rwds_delay 	<= 'b0;
		end
		else if(cal_done_reg && step_passed_indicator != {RWDS_STEPS{1'b0}}) begin
			cal_pass_reg 		<= ~cal_fail;
			locked_rwds_delay  	<= cal_rwds_delay;
		end
		else begin
			cal_pass_reg 		<= cal_pass_reg;
			locked_rwds_delay 	<= locked_rwds_delay;
		end
	end
	assign cal_debug_info = {11'b00000000000, step_passed_indicator, locked_rwds_delay, 3'b000, cal_pass_reg, cal_done_reg};
end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_cal_mst)
(
	input			clk,
	input			rst_n,
	input			init_rdy,
	output reg		cal_rstn,
	output			cal_en,
	input			cal_done,
	input			cal_fail,
	output			mst_cal_done,
	output			mst_cal_fail,
	input 			shift_done
);
localparam [1:0]	CAL_IDLE  = 'b00,
			CAL_OP	  = 'b01,
			CAL_POST  = 'b10,
			CAL_DONE  = 'b11;
reg  [1:0]		cal_state,
			cal_next;
reg  [3:0]		checkin_cnt;
reg  [2:0]		cal_rst_cnt;
reg			cal_fail_r;
wire			cal_check ;
wire			cal_run   ;
reg [4:0] shift_done_delay;
always@ (posedge clk or negedge rst_n)
begin
	if(!rst_n)
		cal_state <= CAL_IDLE;
	else
		cal_state <= cal_next;
end
always@ (*)
begin
	cal_next = cal_state;
	case(cal_state)
	CAL_IDLE:
	begin
		if(init_rdy)
			cal_next = CAL_OP;
		else
			cal_next = CAL_IDLE;
	end
	CAL_OP:
	begin
		if(cal_done && !cal_fail)
			cal_next = CAL_DONE;
		else if(cal_done && cal_fail)
		begin
				cal_next = CAL_DONE;
		end
		else
			cal_next = CAL_OP;
	end
	CAL_POST: 
	begin
		if(shift_done_delay[4] == 1'b1)
			cal_next = CAL_DONE;
		else
			cal_next = CAL_POST;
	end
	CAL_DONE:
	begin
		if(!init_rdy)
			cal_next = CAL_IDLE;
		else
			cal_next = CAL_DONE;
	end
	default : cal_next = CAL_IDLE;
	endcase
end
assign cal_run      = (cal_state == CAL_OP || cal_state == CAL_DONE);
assign cal_check    = (cal_state == CAL_POST);
assign cal_en 	    = (checkin_cnt == 'h0);
assign cal_complete = cal_run & cal_done & shift_done_delay[4];
always@ (posedge clk or negedge cal_run) begin
    if (!cal_run)
        cal_rstn <= 'h0;
    else
        cal_rstn <= cal_run;
end
always@ (posedge clk or negedge rst_n)
begin
	if(!rst_n)
		checkin_cnt <= {4{1'b1}};
	else begin
		if (cal_complete)
			checkin_cnt <= {4{1'b1}};
		else if( cal_run && checkin_cnt != 'h0 )
			checkin_cnt <= checkin_cnt - 1'b1;
		else
			checkin_cnt <= checkin_cnt;
	end
end
always@ (posedge clk or negedge cal_run) begin
    if (!cal_run) begin
        shift_done_delay <= 'h0;
    end
    else if (shift_done && !shift_done_delay[4]) begin
        shift_done_delay <= shift_done_delay + 1'b1;
    end
    else begin
    	shift_done_delay <= shift_done_delay;
    end
end
always@ (posedge clk or negedge rst_n)
begin
	if(!rst_n)
		cal_fail_r <= 1'b0;
	else if(cal_run & cal_done)
		cal_fail_r <= cal_fail;
	else
		cal_fail_r <= cal_fail_r;
end
assign mst_cal_done = (cal_state == CAL_DONE) && shift_done_delay[4];
assign mst_cal_fail = mst_cal_done ? cal_fail_r : 1'b0;
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_cal_ctrl) #(
    parameter        CAL_MODE  = 0,
    parameter        RAM_DBW   = 8,
    parameter        RAM_ABW   = 25,
    parameter [15:0] CFG_CR0   = 0,
    parameter [3:0]  CR0_ILC        = 4'b0010,
    parameter [15:0] CFG_CR1   = 0,
    parameter [47:0] CR0W_CA   = 0,
    parameter [47:0] CR1W_CA   = 0,
    parameter        DQIN_MODE = "RESYNC",
    parameter        SMODE     = 1,
    parameter        TCYC      = 10000,
    parameter        TCSM      = 4000000,
    parameter        TVCS      = 150000000,
    parameter        TRH       = 200000,
    parameter        TRTR      = 40000,
    parameter		 DUAL_RAM  = 1,
    parameter 		 INDIVI_DUAL_CAL = 1,
    parameter		 RAM_DBW_TWO = (DUAL_RAM == 1)? RAM_DBW*2 : RAM_DBW
) (
    input                      	clk               , 
    input                      	clk_cal           ,
    input						clk_cal_2		  , 
    input                      	rst_n             , 
    input                      	calrst_n          , 
    input                      	calrst_n_2        , 
    input                      	h_rst_n           , 
    input                      	h_req             , 
    input                      	h_last            , 
    input   [RAM_ABW-1:0]   	h_addr            , 
    input                   	h_btype           , 
    input                   	h_atype           , 
    input                   	h_rwen            , 
    output                  	h_mrdy            , 
    input   [RAM_DBW_TWO/4-1:0] h_wdm             , 
    input   [RAM_DBW_TWO*2-1:0] h_wdata           , 
    output                  	h_wrdy            , 
    output  [RAM_DBW_TWO*2-1:0] h_rdata           , 
    output                  	h_rdav            , 
    output                  	h_pause           , 
    input                   	h_ctc             , 
    input                   	cal_req           , 
    input                   	cal_last          , 
    input                   	cal_done          , 
    input   [RAM_ABW-1:0]   	cal_addr          , 
    input                   	cal_rwen          , 
    input   [RAM_DBW_TWO*2-1:0] cal_wdata         , 
    output                  	cal_wrdy          , 
    output  [RAM_DBW_TWO*2-1:0] cal_rdata         , 
    output                  	cal_rdav          , 
    input 						mst_cal_done	  ,
    output                     	hbc_rst_n         , 
    output reg                 	hbc_cs_n          , 
    output reg                 	hbc_ck_p_HI       , 
    output reg                 	hbc_ck_p_LO       , 
    output reg                 	hbc_ck_n_HI       , 
    output reg                 	hbc_ck_n_LO       , 
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OUT_HI   , 
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OUT_LO   , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_HI       , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_LO       , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_delay ,
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OE       , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OUT_HI     , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OUT_LO     , 
    input      [RAM_DBW-1:0]   	hbc_dq_IN_HI      , 
    input      [RAM_DBW-1:0]   	hbc_dq_IN_LO      , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OE         , 
    output                     	hbc_rst_n_2         , 
    output reg                 	hbc_cs_n_2          , 
    output reg                 	hbc_ck_p_HI_2       , 
    output reg                 	hbc_ck_p_LO_2       , 
    output reg                 	hbc_ck_n_HI_2       , 
    output reg                 	hbc_ck_n_LO_2       , 
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OUT_HI_2   , 
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OUT_LO_2   , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_HI_2    , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_LO_2    , 
    input      [RAM_DBW/8-1:0] 	hbc_rwds_IN_delay_2 ,
    output reg [RAM_DBW/8-1:0] 	hbc_rwds_OE_2       , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OUT_HI_2     , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OUT_LO_2     , 
    input      [RAM_DBW-1:0]   	hbc_dq_IN_HI_2      , 
    input      [RAM_DBW-1:0]   	hbc_dq_IN_LO_2      , 
    output reg [RAM_DBW-1:0]   	hbc_dq_OE_2           
);
localparam     HBC_POR_STB_DLY     = TVCS%TCYC   ?
                                     TVCS/TCYC+1 :
                                     TVCS/TCYC   ;               
localparam     HBC_POR_STB_CW      = $clog2(HBC_POR_STB_DLY);    
localparam     HBC_RST_STB_DLY     = TRH%TCYC    ?
                                     TRH/TCYC+1  :
                                     TRH/TCYC    ;               
localparam     HBC_RST_STB_CW      = $clog2(HBC_RST_STB_DLY);    
localparam     tRTR_C              = TRTR/TCYC+1 ;
localparam     tRTR_CW             = $clog2(tRTR_C);
localparam     tCSM_C              = TCSM/TCYC   ;
localparam     tCSM_CW             = $clog2(tCSM_C) ;            
localparam     ILC_C               = (CR0_ILC==4'b0000)?  
                                     5:(CR0_ILC==4'b0001)?
                                     6:(CR0_ILC==4'b0010)?
                                     7:(CR0_ILC==4'b1110)?
                                     3:(CR0_ILC==4'b1111)?
                                     4:7;
localparam     INIT                = 4'b0001;                    
localparam     STBY                = 4'b0010;                    
localparam     MCWR                = 4'b0100;                    
localparam     MCRD                = 4'b1000;                    
reg              			hbc_por_standby;           
reg [HBC_POR_STB_CW-1:0] 	hbc_por_cnt;               
reg              			hbc_rst_standby;           
reg [HBC_RST_STB_CW-1:0] 	hbc_rst_cnt;               
reg              			hbc_stanby;                
wire                      	i_req;
wire                      	i_last;
wire [RAM_ABW-1:0]          i_addr;
wire                      	i_btype;
wire                      	i_atype;
wire                      	i_rwen;
wire [RAM_DBW_TWO/4-1:0]    i_wdm;
wire [RAM_DBW_TWO*2-1:0]    i_wdata;
reg                       	i_wrdy;
reg                  		f_wrdy;
reg  [RAM_DBW_TWO*2-1:0]    i_rdata;
wire [RAM_DBW_TWO*2-1:0]    rd_fifo_rdata;
wire [RAM_DBW*2-1:0]    wr_fifo_rdata;
wire [RAM_DBW*2-1:0]    wr_fifo_rdata_2;
wire rd_fifo_empty;
reg              i_rdav;
wire             o_rdav;
wire             fifo_rdav;
reg  [3:0]       state;
reg              atype_req;
reg              btype_req;
reg              rwen_req;
reg              mcwr_req;
reg              mcrd_req;
reg              init_done;
reg              tRTR_rdy;
reg              mcwr_done;
reg              mcrd_done;
reg              init_flag;
reg              stby_flag;
reg              mcwr_flag;
reg              mcrd_flag;
wire             i_req_latch;
reg              i_req_1r;
reg  [5:0]       init_cnt;
wire [15:0]      init_cr0;
wire [15:0]      init_cr1;
reg              init_cs_n;
reg                     init_ck_en;
reg  [RAM_DBW-1:0]  init_dq_OUT_HI;
reg  [RAM_DBW-1:0]  init_dq_OUT_LO;
wire [RAM_DBW-1:0]  init_dq_OE;
reg  [tRTR_CW-1:0]     	stby_cnt;
reg              		addr_cnt_load;
reg  [tCSM_CW-1:0]      tCSM_cnt;
wire              		i_ctc;
wire              		i_read_cp;
reg  [4:0]          	latency;
reg             		latency_updated;
reg  [tCSM_CW-1:0]      addr_cnt;
wire [31:RAM_ABW]      	ca_addr_HI;
reg  [RAM_ABW-1:0]      ca_addr_LO;
wire [31:0]          	ca_addr;
reg  [RAM_DBW-1:0]  ca [0:5];
reg                     	mcwr_cs_n;
reg                     	mcwr_ck_en;
reg  [RAM_DBW/8-1:0]    	mcwr_rwds_OE;
wire [RAM_DBW/8-1:0]    	mcwr_rwds_OUT_HI;
wire [RAM_DBW/8-1:0]    	mcwr_rwds_OUT_LO;
reg  [RAM_DBW-1:0]      	mcwr_dq_OUT_HI;
reg  [RAM_DBW-1:0]      	mcwr_dq_OUT_LO;
reg  [RAM_DBW-1:0]      	mcwr_dq_OE;
reg                     	mcrd_cs_n;
reg                     	mcrd_ck_en;
reg  [RAM_DBW-1:0]      	mcrd_dq_OUT_HI;
reg  [RAM_DBW-1:0]      	mcrd_dq_OUT_LO;
reg  [RAM_DBW-1:0]      	mcrd_dq_OE;
reg  [RAM_DBW-1:0]      	hbc_dq_IN_HI_reg;
reg  [RAM_DBW-1:0]      	hbc_dq_IN_LO_reg;
wire                    	hbc_ck_en;
wire hbc_cs_n_en;
reg  [RAM_DBW/8-1:0]    	mcwr_rwds_OE_2;
wire [RAM_DBW/8-1:0]    	mcwr_rwds_OUT_HI_2;
wire [RAM_DBW/8-1:0]    	mcwr_rwds_OUT_LO_2;
reg  [RAM_DBW-1:0]      mcwr_dq_OUT_HI_2;
reg  [RAM_DBW-1:0]      mcwr_dq_OUT_LO_2;
reg  [RAM_DBW-1:0]      mcwr_dq_OE_2;
reg  [RAM_DBW-1:0]      hbc_dq_IN_HI_reg_2;
reg  [RAM_DBW-1:0]      hbc_dq_IN_LO_reg_2;
wire                    hbc_ck_en_2;
reg fifo_wr_en;
reg fifo_rd_en_1;
reg fifo_rd_en_2;
wire i_rdav_fifo;
wire rdfifo_rdav_1;
wire rdfifo_rdav_2;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          hbc_por_cnt <=  'd0;
     end
     else if (hbc_por_cnt < HBC_POR_STB_DLY) begin
          hbc_por_cnt <=  hbc_por_cnt + 1'b1;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
          hbc_por_standby <=  1'b0;
     end
     else begin
          hbc_por_standby <=  hbc_por_cnt == HBC_POR_STB_DLY;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          hbc_rst_cnt <=  'd0;
     end
     else if (!h_rst_n) begin
          hbc_rst_cnt <=  'd0;
     end
     else if (hbc_rst_cnt < HBC_RST_STB_DLY) begin
          hbc_rst_cnt <=  hbc_rst_cnt + 1'b1;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
          hbc_rst_standby <=  1'b0;
     end
     else begin
          hbc_rst_standby <=  hbc_rst_cnt == HBC_RST_STB_DLY;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if(!rst_n) begin
          hbc_stanby <=  1'b0;
     end
     else begin
          hbc_stanby <=  hbc_por_standby & hbc_rst_standby;
     end
end
assign hbc_rst_n = h_rst_n;
assign hbc_rst_n_2 = h_rst_n;
assign i_req     = cal_done ? h_req  : cal_req;
assign i_last    = cal_done ? h_last : cal_last;
assign i_addr    = cal_done ? h_addr : cal_addr;
assign i_btype   = cal_done ? h_btype: 1'b1;
assign i_atype   = cal_done ? h_atype: 1'b0;
assign i_rwen    = cal_done ? h_rwen : cal_rwen;
assign i_wdm     = cal_done ? h_wdm  : {(RAM_DBW_TWO/4){1'b0}};
assign i_wdata   = cal_done ? h_wdata: cal_wdata;
assign h_wrdy    = f_wrdy;
assign cal_wrdy  = cal_done ? 1'b0   : i_wrdy;
wire h_rdav_test;
reg i_rdav_final;
generate
   if (SMODE==0) begin  
         assign h_rdata   = cal_done ? i_rdata : 1'b0;
         assign cal_rdata = cal_done ? 32'd0  : i_rdata;
         assign h_rdav    = cal_done ? i_rdav : 1'b0;
         assign cal_rdav  = cal_done ? 1'b0   : i_rdav;
   end
  else if (SMODE==1 && DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin  
         assign h_rdata   = cal_done ? rd_fifo_rdata : 32'b0;
         assign cal_rdata = cal_done ? 32'd0  : rd_fifo_rdata;
         assign h_rdav    = cal_done ? rdfifo_rdav_1 && rdfifo_rdav_2   : 1'b0;
         assign cal_rdav  = cal_done ? 1'b0   : rdfifo_rdav_1 || rdfifo_rdav_2  ;
   end
   else begin
   	     assign h_rdata   = cal_done ? rd_fifo_rdata : 16'b0;
         assign cal_rdata = cal_done ? 16'd0  : rd_fifo_rdata;
         assign h_rdav    = cal_done ? i_rdav_fifo : 1'b0;
         assign cal_rdav  = cal_done ? 1'b0   : i_rdav_fifo;
   end
endgenerate
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          i_req_1r <=  1'b0;
     end
     else begin
         i_req_1r <= i_req;
     end
end
assign i_req_latch = i_req & ~i_req_1r ;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          btype_req <=  1'b0;
          atype_req <=  1'b0;
          rwen_req <=  1'b0;
          mcwr_req <=  1'b0;
          mcrd_req <=  1'b0;
     end
     else if(i_req_latch) begin
          btype_req <=  i_btype;
          atype_req <=  i_atype;
          rwen_req <=  i_rwen;
          mcwr_req <=  i_req&~i_rwen;
          mcrd_req <=  i_req&i_rwen;
     end
     else if (i_last) begin
          mcwr_req <=  1'b0;
          mcrd_req <=  1'b0;
     end
end
always @ ( * )
begin
     init_flag <= state[0];
         stby_flag <= state[1];
         mcwr_flag <= state[2];
         mcrd_flag <= state[3];
    end
    assign h_mrdy = ~init_flag;
    always @ (posedge clk or negedge rst_n)
    begin
         if (!rst_n) begin
          state <=  INIT;
         end
         else begin
          case (state)
               INIT:
                if (init_done)
                 state <=  STBY;
                else
                 state <=  INIT;
               STBY:
                if (!hbc_stanby)
                 state <=  INIT;
                else if(mcwr_req&tRTR_rdy)
                 state <=  MCWR;
                else if(mcrd_req&tRTR_rdy)
                 state <=  MCRD;
                else
                 state <=  STBY;
               MCWR:
                if (!hbc_stanby)
                 state <=  INIT;
                else if(mcwr_done)
                 state <=  STBY;
                else
                 state <=  MCWR;
               MCRD:
                if (!hbc_stanby)
                 state <=  INIT;
                else if(mcrd_done)
                 state <=  STBY;
                else
                 state <=  MCRD;
               default:
                state <=  INIT;
          endcase
         end
    end
    assign init_cr0 = CFG_CR0;
    assign init_cr1 = CFG_CR1;
    always @ (posedge clk or negedge rst_n)
    begin
         if (!rst_n) begin
          init_cnt <=  6'd0;
         end
         else if(!hbc_stanby) begin
          init_cnt <=  6'd0;
         end
         else if(init_cnt<5'd31) begin
          init_cnt <=  init_cnt + 1'b1;
         end
    end
    always @ (posedge clk or negedge rst_n)
    begin
         if (!rst_n) begin
          init_done <=  1'b0;
         end
         else begin
          init_done <=  init_cnt == 5'd30;
         end
    end
    always @ (posedge clk or negedge rst_n)
    begin
         if (!rst_n) begin
          init_cs_n <=  1'b1;
         end
         else begin
          init_cs_n <=  ~((init_cnt>=5'd1 & init_cnt<=5'd6) | (init_cnt>=5'd18 & init_cnt<=5'd23));
         end
    end
    always @ (posedge clk or negedge rst_n)
    begin
         if (!rst_n) begin
          init_ck_en <=  1'b0;
         end
         else begin
          init_ck_en <=  ((init_cnt>=5'd2 & init_cnt<=5'd5) | (init_cnt>=5'd19 & init_cnt<=5'd22));
         end
    end
    assign init_dq_OE = {RAM_DBW{1'b1}};
    always @ (posedge clk or negedge rst_n)
    begin
         if(!rst_n) begin
          init_dq_OUT_HI <=  {RAM_DBW{1'b0}};
          init_dq_OUT_LO <=  {RAM_DBW{1'b0}};
         end
         else begin
               case (init_cnt)
               5'd2:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR0W_CA[7:0]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR0W_CA[15:8]}};
                end
               5'd3:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR0W_CA[23:16]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR0W_CA[31:24]}};
                end
               5'd4:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR0W_CA[39:32]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR0W_CA[47:40]}};
                end
               5'd5:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{init_cr0[15:8]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{init_cr0[7:0]}};
                end
               5'd19:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR1W_CA[7:0]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR1W_CA[15:8]}};
                end
               5'd20:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR1W_CA[23:16]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR1W_CA[31:24]}};
                end
               5'd21:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{CR1W_CA[39:32]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{CR1W_CA[47:40]}};
                end
               5'd22:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW/8{init_cr1[15:8]}};
                 init_dq_OUT_LO <=  {RAM_DBW/8{init_cr1[7:0]}};
                end
               default:
                begin
                 init_dq_OUT_HI <=  {RAM_DBW{1'b0}};
                 init_dq_OUT_LO <=  {RAM_DBW{1'b0}};
                end
          endcase
         end
    end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          stby_cnt <=  {tRTR_CW{1'b0}};
     end
     else if (stby_flag) begin
          if (stby_cnt == {tRTR_CW{1'b1}})begin
               stby_cnt <=  stby_cnt;
          end
          else begin
               stby_cnt <=  stby_cnt + 1'b1;
          end
     end
     else begin
          stby_cnt <=  {tRTR_CW{1'b0}};
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          tRTR_rdy <=  1'b0;
     end
     else begin
          tRTR_rdy <=  stby_cnt >= tRTR_C-4;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          addr_cnt_load <=  1'b0;
     end
     else begin
          addr_cnt_load <=  stby_cnt == tRTR_C-3;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          tCSM_cnt <=  'd0;
     end
     else if (i_ctc) begin
          tCSM_cnt <=  'd0;
     end
     else if (mcwr_flag|mcrd_flag) begin
          tCSM_cnt <=  tCSM_cnt + 1'b1;
     end
     else begin
          tCSM_cnt <=  'd0;
     end
end
assign i_ctc = i_last | h_ctc;
assign h_pause = (tCSM_cnt == tCSM_C-10);
assign i_read_cp = i_last | h_ctc;
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          latency <=  2+2*ILC_C;
     end
     else begin
          latency <= 2+2*ILC_C; 
     end
end
always @(posedge clk or negedge rst_n)
begin
    if(!rst_n)
        latency_updated <= 1'b0;
    else if (mcrd_done || mcwr_done)
        latency_updated <= 1'b0;
    else if(tCSM_cnt == 'd3 || atype_req&mcwr_flag)
        latency_updated <= 1'b1;
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          addr_cnt <=  'd0;
     end
     else if (i_req_latch) begin
          addr_cnt <=  'd0;
     end
     else if (mcwr_flag&i_ctc) begin
          addr_cnt <=  tCSM_cnt - latency ;
     end
     else if (mcrd_flag&i_ctc) begin
          addr_cnt <=  tCSM_cnt - (latency/* + 1*/) ;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          ca_addr_LO <=  'd0;
     end
     else if (i_req_latch) begin
          ca_addr_LO <=  i_addr;
     end
     else if (addr_cnt_load) begin
          ca_addr_LO <=   ca_addr_LO[RAM_ABW-1:0] + addr_cnt;
     end
end
assign ca_addr = ca_addr_LO;
always @ ( * )
begin
     ca[0] = {rwen_req,atype_req,btype_req,ca_addr[31:27]};
     ca[1] = ca_addr[26:19];
     ca[2] = ca_addr[18:11];
     ca[3] = ca_addr[10:3];
     ca[4] = 8'b00000000;
     ca[5] = {5'b00000,ca_addr[2:0]};
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          mcwr_done <=  1'b0;
     end
     else begin
          mcwr_done <=  i_ctc;
     end
end
reg i_ctc_p;
always @ (posedge clk or negedge rst_n) begin
	if (!rst_n) begin
         i_ctc_p <=  1'b0;
     end
     else begin
         i_ctc_p <= i_ctc;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
         mcwr_cs_n <=  1'b1;
     end
     else if(i_ctc_p) begin
         mcwr_cs_n <=  1'b1;
     end
     else if(mcwr_req&tRTR_rdy) begin
         mcwr_cs_n <=  1'b0;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          mcwr_ck_en <=  1'b0;
     end
     else if(mcwr_flag&tRTR_rdy) begin
          mcwr_ck_en <=  1'b1;
     end
     else if(i_ctc) begin
          mcwr_ck_en <=  1'b0;
     end
end
always @ ( * )
begin
     if(atype_req) begin
          mcwr_rwds_OE <= {RAM_DBW/8{1'b0}};
     end
     else begin
          mcwr_rwds_OE <= {RAM_DBW/8{tCSM_cnt >={5'b0,latency}}};
     end
end
generate
genvar i;
for (i=0;i < RAM_DBW/8;i=i+1) begin:MCWR_RWDS_OUT_GEN
     assign mcwr_rwds_OUT_LO[i] = i_wdm[i+(RAM_DBW/8)] & ~(tCSM_cnt == {5'b0,latency});
     assign mcwr_rwds_OUT_HI[i] = i_wdm[i]  & ~(tCSM_cnt == {5'b0,latency});
     if (DUAL_RAM == 1 && RAM_DBW == 16) begin
     	 assign mcwr_rwds_OUT_LO_2[i] = i_wdm[i+(RAM_DBW_TWO/8)+2] & ~(tCSM_cnt == {5'b0,latency});
     	 assign mcwr_rwds_OUT_HI_2[i] = i_wdm[i+(RAM_DBW_TWO/8)]  & ~(tCSM_cnt == {5'b0,latency});
     end
     else if (DUAL_RAM == 1 && RAM_DBW == 8) begin
     	 assign mcwr_rwds_OUT_LO_2[i] = i_wdm[i+(RAM_DBW_TWO/8)+1] & ~(tCSM_cnt == {5'b0,latency});
     	 assign mcwr_rwds_OUT_HI_2[i] = i_wdm[i+(RAM_DBW_TWO/8)]  & ~(tCSM_cnt == {5'b0,latency});
     end
end
endgenerate
always @ ( * )
begin
     mcwr_dq_OE <= {RAM_DBW{(tCSM_cnt>='d1 & tCSM_cnt<='d3)|(tCSM_cnt>{5'b0,latency})}};
end
generate
	if (DUAL_RAM == 1) begin
		genvar j;
		for (j=0;j < RAM_DBW;j=j+1) begin:mcwr_dq_OUT_GEN_DUAL_RAM
			 always @ ( * ) begin
			  case(tCSM_cnt)
				   'd1:
						begin 
							 mcwr_dq_OUT_HI[j] 			<= ca[0][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[1][j];
							 mcwr_dq_OUT_HI_2[j] 		<= ca[0][j];
							 mcwr_dq_OUT_LO_2[j] 		<= ca[1][j];
						end
				   'd2:
						begin
							 mcwr_dq_OUT_HI[j] 			<= ca[2][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[3][j];
							 mcwr_dq_OUT_HI_2[j] 		<= ca[2][j];
							 mcwr_dq_OUT_LO_2[j] 		<= ca[3][j];
						end
				   'd3:
						begin
							 mcwr_dq_OUT_HI[j] 			<= ca[4][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[5][j];
							 mcwr_dq_OUT_HI_2[j] 		<= ca[4][j];
							 mcwr_dq_OUT_LO_2[j] 		<= ca[5][j];
						end
				   default:
						begin
							 mcwr_dq_OUT_HI[j] 			<= i_wdata[j+RAM_DBW];				
							 mcwr_dq_OUT_LO[j] 			<= i_wdata[j];						
							 mcwr_dq_OUT_HI_2[j] 		<= i_wdata[j+RAM_DBW_TWO+RAM_DBW]; 	
							 mcwr_dq_OUT_LO_2[j] 		<= i_wdata[j+RAM_DBW_TWO];			
						end
			  endcase
			 end
		end
    end
    else begin 
		genvar j;
		for (j=0;j < RAM_DBW;j=j+1) begin:mcwr_dq_OUT_GEN
			 always @ ( * ) begin
			  case(tCSM_cnt)
				   'd1:
						begin
							 mcwr_dq_OUT_HI[j] 			<= ca[0][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[1][j];
						end
				   'd2:
						begin
							 mcwr_dq_OUT_HI[j] 			<= ca[2][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[3][j];
						end
				   'd3:
						begin
							 mcwr_dq_OUT_HI[j] 			<= ca[4][j];
							 mcwr_dq_OUT_LO[j] 			<= ca[5][j];
						end
				   default:
						begin
							 mcwr_dq_OUT_HI[j] 			<= i_wdata[j+RAM_DBW];
							 mcwr_dq_OUT_LO[j] 			<= i_wdata[j];
						end
			  endcase
			 end
		end
    end
endgenerate
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          i_wrdy <=  1'b0;
     end
     else if(i_ctc) begin
          i_wrdy <=  1'b0;
     end
     else if(tCSM_cnt == latency && latency_updated) begin
          i_wrdy <=  mcwr_flag;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          f_wrdy <=  1'b0;
     end
     else if(i_ctc) begin
          f_wrdy <=  1'b0;
     end
     else if(tCSM_cnt == latency - 2 && latency_updated) begin
          f_wrdy <=  1'b1;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          mcrd_done <=  1'b0;
     end
     else begin
          mcrd_done <=  i_ctc;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          mcrd_cs_n <=  1'b1;
     end
     else if(i_ctc_p) begin
          mcrd_cs_n <=  1'b1;
     end
     else if(mcrd_req&tRTR_rdy) begin
          mcrd_cs_n <=  1'b0;
     end
end
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          mcrd_ck_en <=  1'b0;
     end
     else if(mcrd_flag&tRTR_rdy) begin
          mcrd_ck_en <=  1'b1;
     end
     else if(i_ctc) begin
          mcrd_ck_en <=  1'b0;
     end
end
always @ ( * )
begin
     mcrd_dq_OE <= {RAM_DBW{tCSM_cnt>='d1 & tCSM_cnt<='d3}};
end
always @ ( * ) 
begin
     case(tCSM_cnt)
          'd1:
               begin
                    mcrd_dq_OUT_HI <= ca[0];
                    mcrd_dq_OUT_LO <= ca[1];
               end
          'd2:
               begin
                    mcrd_dq_OUT_HI <= ca[2];
                    mcrd_dq_OUT_LO <= ca[3];
               end
          'd3:
               begin
                    mcrd_dq_OUT_HI <= ca[4];
                    mcrd_dq_OUT_LO <= ca[5];
               end
          default:
               begin
                    mcrd_dq_OUT_HI <= 'd0;
                    mcrd_dq_OUT_LO <= 'd0;
               end
     endcase
end
(*syn_preserve="true"*) reg  [RAM_DBW-1:0]       hbc_dq_IN_HI_reg_p0;
(*syn_preserve="true"*) reg  [RAM_DBW/8-1:0]     hbc_rwds_IN_HI_reg_p0;
(*syn_preserve="true"*) reg  [RAM_DBW/8-1:0]     hbc_rwds_IN_LO_reg_p0;
(*syn_preserve="true"*) reg  [RAM_DBW-1:0]       hbc_dq_IN_HI_reg_p0_2;
(*syn_preserve="true"*) reg  [RAM_DBW/8-1:0]     hbc_rwds_IN_HI_reg_p0_2;
(*syn_preserve="true"*) reg  [RAM_DBW/8-1:0]     hbc_rwds_IN_LO_reg_p0_2;
generate
genvar k;
if(CAL_MODE == 1) begin 
    for (k=0;k<RAM_DBW/8;k=k+1) begin : i_rdata_strb
           if (DQIN_MODE == "NORMAL") begin
                  always @(posedge hbc_rwds_IN_delay[k]) begin hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI[k*8+7 -: 8]; end
                  always @(posedge hbc_rwds_IN_delay[k]) begin hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO[k*8+7 -: 8]; end
           end
           else if (DQIN_MODE == "RESYNC") begin
                  always @(posedge hbc_rwds_IN_delay[k]) begin hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI[k*8+7 -: 8]; end
                  always @(*)                            begin hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO[k*8+7 -: 8]; end
           end
           else begin 
                  always @(*) begin hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI[k*8+7 -: 8]; end
                  always @(*) begin hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO[k*8+7 -: 8]; end
           end
    end
end
else if(CAL_MODE ==  3 || CAL_MODE == 2)
begin
    for (k=0;k<RAM_DBW/8;k=k+1) begin : i_rdata_strb_auto
		if(DQIN_MODE == "NORMAL") begin
			always @(posedge clk_cal or negedge rst_n) begin
				if(!rst_n) begin
					hbc_dq_IN_HI_reg[k*8+7 -: 8] <= 'h0;
					hbc_dq_IN_LO_reg[k*8+7 -: 8] <= 'h0;
				end
				else begin
					if(hbc_rwds_IN_HI[k] && (!hbc_rwds_IN_LO[k])) begin
						hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI[k*8+7 -: 8];
						hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO[k*8+7 -: 8];
					end
					else begin
						hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI_reg[k*8+7 -: 8];
						hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO_reg[k*8+7 -: 8];
					end
				end
			end
			if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
				always @(posedge clk_cal or negedge rst_n) begin
					if(!rst_n) begin
						hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= 'h0;
						hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						if(hbc_rwds_IN_HI_2[k] && (!hbc_rwds_IN_LO_2[k])) begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_2[k*8+7 -: 8];
						end
						else begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_reg_2[k*8+7 -: 8];
						end
					end
				end
			end
			else if (DUAL_RAM == 1) begin
				always @(posedge clk_cal or negedge rst_n) begin
					if(!rst_n) begin
						hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= 'h0;
						hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						if(hbc_rwds_IN_HI_2[k] && (!hbc_rwds_IN_LO_2[k])) begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_2[k*8+7 -: 8];
						end
						else begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_reg_2[k*8+7 -: 8];
						end
					end
				end
			end
		end
		else if(DQIN_MODE == "RESYNC") begin
			always @(posedge clk_cal or negedge calrst_n) begin
				if(!calrst_n) begin
					hbc_dq_IN_HI_reg[k*8+7 -: 8] <= 'h0;
					hbc_dq_IN_LO_reg[k*8+7 -: 8] <= 'h0;
				end
				else begin
					if(hbc_rwds_IN_HI_reg_p0[k] && (!hbc_rwds_IN_LO[k])) begin
						hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_p0[k*8+7 -: 8];
						hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO[k*8+7 -: 8];
					end
					else begin
						hbc_dq_IN_HI_reg[k*8+7 -: 8] <= hbc_dq_IN_HI_reg[k*8+7 -: 8];
						hbc_dq_IN_LO_reg[k*8+7 -: 8] <= hbc_dq_IN_LO_reg[k*8+7 -: 8];
					end
				end
			end
			always @(posedge clk_cal or negedge calrst_n) begin
				if(!calrst_n) begin
					hbc_rwds_IN_HI_reg_p0[k] 		<= 'b0;
					hbc_rwds_IN_LO_reg_p0[k] 		<= 'b0;
					hbc_dq_IN_HI_reg_p0[k*8+7 -: 8] <= 'h0;
				end
				else begin
					hbc_rwds_IN_HI_reg_p0[k]     	<= hbc_rwds_IN_HI[k];
					hbc_rwds_IN_LO_reg_p0[k]     	<= hbc_rwds_IN_LO[k];
					hbc_dq_IN_HI_reg_p0[k*8+7 -: 8] <= hbc_dq_IN_HI[k*8+7 -: 8];
				end
			end
			if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
				always @(posedge clk_cal_2 or negedge calrst_n_2) begin 
					if(!calrst_n_2) begin
						hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= 'h0;
						hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						if(hbc_rwds_IN_HI_reg_p0_2[k] && (!hbc_rwds_IN_LO_2[k])) begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_2[k*8+7 -: 8];
						end
						else begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_reg_2[k*8+7 -: 8];
						end
					end
				end
				always @ (posedge clk_cal_2 or negedge calrst_n_2) begin 
					if(!calrst_n_2) begin
						hbc_rwds_IN_HI_reg_p0_2[k] 		<= 'b0;
						hbc_rwds_IN_LO_reg_p0_2[k] 		<= 'b0;
						hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						hbc_rwds_IN_HI_reg_p0_2[k]     	<= hbc_rwds_IN_HI_2[k];
						hbc_rwds_IN_LO_reg_p0_2[k]     	<= hbc_rwds_IN_LO_2[k];
						hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8] <= hbc_dq_IN_HI_2[k*8+7 -: 8];
					end
				end
			end
			else if (DUAL_RAM == 1) begin
				always @(posedge clk_cal or negedge calrst_n_2) begin 
					if(!calrst_n_2) begin
						hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= 'h0;
						hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						if(hbc_rwds_IN_HI_reg_p0_2[k] && (!hbc_rwds_IN_LO_2[k])) begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_2[k*8+7 -: 8];
						end
						else begin
							hbc_dq_IN_HI_reg_2[k*8+7 -: 8] <= hbc_dq_IN_HI_reg_2[k*8+7 -: 8];
							hbc_dq_IN_LO_reg_2[k*8+7 -: 8] <= hbc_dq_IN_LO_reg_2[k*8+7 -: 8];
						end
					end
				end
				always @ (posedge clk_cal or negedge calrst_n_2) begin 
					if(!calrst_n_2) begin
						hbc_rwds_IN_HI_reg_p0_2[k] 		<= 'b0;
						hbc_rwds_IN_LO_reg_p0_2[k] 		<= 'b0;
						hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8] <= 'h0;
					end
					else begin
						hbc_rwds_IN_HI_reg_p0_2[k]     	<= hbc_rwds_IN_HI_2[k];
						hbc_rwds_IN_LO_reg_p0_2[k]     	<= hbc_rwds_IN_LO_2[k];
						hbc_dq_IN_HI_reg_p0_2[k*8+7 -: 8] <= hbc_dq_IN_HI_2[k*8+7 -: 8];
					end
				end
			end
		end
    end
end
endgenerate
generate
	reg rdfifo_wr_en_1;
	reg rdfifo_wr_en_2;
	reg rdfifo_wr_en;
	if (DUAL_RAM == 1 && CAL_MODE == 2) begin
		if (DQIN_MODE == "RESYNC") begin
			always @(posedge clk_cal or negedge calrst_n) begin
				if (!calrst_n) begin
					rdfifo_wr_en_1 <= 0;
				end
				else if (hbc_rwds_IN_HI_reg_p0 && !hbc_rwds_IN_LO && !hbc_rwds_IN_LO_reg_p0) begin
					rdfifo_wr_en_1 <= 1;
				end
				else begin
					rdfifo_wr_en_1 <= 0;
				end
			end
			if (INDIVI_DUAL_CAL == 1) begin
				always @(posedge clk_cal_2 or negedge calrst_n_2) begin
					if (!calrst_n_2) begin
						rdfifo_wr_en_2 <= 0;
					end
					else if (hbc_rwds_IN_HI_reg_p0_2 && (!hbc_rwds_IN_LO_2) && !hbc_rwds_IN_LO_reg_p0_2) begin
						rdfifo_wr_en_2 <= 1;
					end
					else begin
						rdfifo_wr_en_2 <= 0;
					end
				end
			end else begin 
				always @(posedge clk_cal or negedge calrst_n_2) begin
					if (!calrst_n_2) begin
						rdfifo_wr_en_2 <= 0;
					end
					else if (hbc_rwds_IN_HI_reg_p0_2 && (!hbc_rwds_IN_LO_2) && !hbc_rwds_IN_LO_reg_p0_2) begin
						rdfifo_wr_en_2 <= 1;
					end
					else begin
						rdfifo_wr_en_2 <= 0;
					end
				end
			end
		end
		else if (DQIN_MODE == "NORMAL") begin
			always @(posedge clk_cal or negedge calrst_n) begin
				if (!calrst_n) begin
					rdfifo_wr_en_1 <= 0;
				end
				else if (hbc_rwds_IN_HI && (!hbc_rwds_IN_LO)) begin
					rdfifo_wr_en_1 <= 1;
				end
				else begin
					rdfifo_wr_en_1 <= 0;
				end
			end
			always @(posedge clk_cal_2 or negedge calrst_n_2) begin
				if (!calrst_n_2) begin
					rdfifo_wr_en_2 <= 0;
				end
				else if (hbc_rwds_IN_HI_2 && (!hbc_rwds_IN_LO_2)) begin
					rdfifo_wr_en_2 <= 1;
				end
				else begin
					rdfifo_wr_en_2 <= 0;
				end
			end
		end
	end
	else begin
		always @ (posedge clk_cal or negedge calrst_n) begin
			if (!calrst_n) begin
				rdfifo_wr_en <= 0;
			end
			else if (hbc_rwds_IN_HI_reg_p0 && !hbc_rwds_IN_LO && !hbc_rwds_IN_LO_reg_p0) begin 
				rdfifo_wr_en <= 1;
			end
			else begin
				rdfifo_wr_en <= 0;
			end
		end
	end
endgenerate
generate
	if (SMODE == 0) begin
	always @ (posedge clk) begin
				i_rdata[RAM_DBW  +: RAM_DBW]  <=  hbc_dq_IN_HI_reg[0 +: RAM_DBW];
				i_rdata[0        +: RAM_DBW]  <=  hbc_dq_IN_LO_reg[0 +: RAM_DBW];
	end
	end
endgenerate
wire rdfifo_empty_1;
wire rdfifo_empty_2;
wire rdfifo_full_1;
wire rdfifo_full_2;
wire rdfifo_wr_en_w;
wire prog_empty_1;
wire prog_empty_2;
generate
   if (SMODE==1) begin
	  assign wr_fifo_rdata[0 +: RAM_DBW] 			= hbc_dq_IN_LO_reg[0 +: RAM_DBW];
	  assign wr_fifo_rdata[RAM_DBW  +: RAM_DBW]  	= hbc_dq_IN_HI_reg[0 +: RAM_DBW];
	  if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin 
	  	  assign wr_fifo_rdata_2[0 +: RAM_DBW] 			= hbc_dq_IN_LO_reg_2[0 +: RAM_DBW];
	  	  assign wr_fifo_rdata_2[RAM_DBW  +: RAM_DBW]  	= hbc_dq_IN_HI_reg_2[0 +: RAM_DBW];
		  always @(posedge clk or negedge rst_n) begin 
				if (!rst_n) begin
					fifo_rd_en_1 <= 1'b0;
				end
				else if (~rdfifo_empty_1 && ~rdfifo_empty_2) begin
					fifo_rd_en_1 <= 1'b1;
				end
				else if (~prog_empty_1 && rdfifo_empty_2) begin
					fifo_rd_en_1 <= 1'b1;
				end
				else if (~rdfifo_empty_1) begin
					fifo_rd_en_1 <= fifo_rd_en_1;
				end
				else if (rdfifo_empty_1 && rdfifo_empty_2) begin
					fifo_rd_en_1 <= 1'b0;
				end
				else begin
					fifo_rd_en_1 <= 1'b0;
				end
		  end
	  	  always @(posedge clk or negedge rst_n) begin 
				if (!rst_n) begin
					fifo_rd_en_2 <= 1'b0;
				end
				else if (~rdfifo_empty_1 && ~rdfifo_empty_2) begin
					fifo_rd_en_2 <= 1'b1;
				end
				else if (rdfifo_empty_1 && ~prog_empty_2) begin
					fifo_rd_en_2 <= 1'b1;
				end
				else if (~rdfifo_empty_2) begin
					fifo_rd_en_2 <= fifo_rd_en_2;
				end
				else if (rdfifo_empty_1 && rdfifo_empty_2) begin
					fifo_rd_en_2 <= 1'b0;
				end
				else begin
					fifo_rd_en_2 <= 1'b0;
				end
		  end
	  	  `IP_MODULE_NAME(efx_fifo_top) #(
	  	  	 .FAMILY 			 ("TITANIUM"),
             .SYNC_CLK           (0),
             .OUTPUT_REG         (0),
             .MODE               ("STANDARD"),
             .PIPELINE_REG       (1),
             .OPTIONAL_FLAGS     (1),
             .PROGRAMMABLE_FULL  ("NONE"),
             .PROG_EMPTY_ASSERT 	(5),
             .PROGRAMMABLE_EMPTY  	("STATIC_SINGLE"),
             .PROG_EMPTY_NEGATE 	(5),
             .ASYM_WIDTH_RATIO   (4),
             .DATA_WIDTH         (RAM_DBW_TWO),
             .DEPTH              (16)
         ) rd_data_fifo_1 (
             .a_rst_i        (~rst_n),
             .wr_clk_i       (clk_cal),
             .rd_clk_i       (clk),
             .wr_en_i        (rdfifo_wr_en_1),
             .wdata          (wr_fifo_rdata),
             .rd_en_i        (fifo_rd_en_1),
             .rdata          (rd_fifo_rdata[RAM_DBW_TWO-1:0]),
             .rd_valid_o     (rdfifo_rdav_1),
             .prog_empty_o 	(prog_empty_1),
             .empty_o        (rdfifo_empty_1)
         );
         `IP_MODULE_NAME(efx_fifo_top) #(
         	 .FAMILY 			 ("TITANIUM"),
             .SYNC_CLK           (0),
             .OUTPUT_REG         (0),
             .MODE               ("STANDARD"),
             .PIPELINE_REG       (1),
             .OPTIONAL_FLAGS     (1),
             .PROGRAMMABLE_FULL  ("NONE"),
             .PROG_EMPTY_ASSERT 	(5),
             .PROGRAMMABLE_EMPTY  	("STATIC_SINGLE"),
             .PROG_EMPTY_NEGATE 	(5),
             .ASYM_WIDTH_RATIO   (4),
             .DATA_WIDTH         (RAM_DBW_TWO),
             .DEPTH              (16)
         ) rd_data_fifo_2 (
             .a_rst_i        (~rst_n),
             .wr_clk_i       (clk_cal_2),
             .rd_clk_i       (clk),
             .wr_en_i        (rdfifo_wr_en_2),
             .wdata          (wr_fifo_rdata_2),
             .rd_en_i        (fifo_rd_en_2),
             .rdata          (rd_fifo_rdata [(RAM_DBW_TWO*2)-1:RAM_DBW_TWO]),
             .rd_valid_o     (rdfifo_rdav_2),
             .prog_empty_o 	(prog_empty_2),
             .empty_o        (rdfifo_empty_2)
         );
	  end
	  else if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 0) begin 
		  assign rdfifo_wr_en_w = rdfifo_wr_en_1 || rdfifo_wr_en_2;
		  assign wr_fifo_rdata_2[0 +: RAM_DBW] 			= hbc_dq_IN_LO_reg_2[0 +: RAM_DBW];
		  assign wr_fifo_rdata_2[RAM_DBW  +: RAM_DBW]  	= hbc_dq_IN_HI_reg_2[0 +: RAM_DBW];
         `IP_MODULE_NAME(efx_fifo_top) #(
             .SYNC_CLK           (0),
             .OUTPUT_REG         (0),
             .MODE               ("STANDARD"),
             .PIPELINE_REG       (1),
             .OPTIONAL_FLAGS     (1),
             .PROGRAMMABLE_FULL  ("NONE"),
             .PROGRAMMABLE_EMPTY ("NONE"),
             .ASYM_WIDTH_RATIO   (4),
             .DATA_WIDTH         (RAM_DBW_TWO*2),
             .DEPTH              (16)
         ) rd_data_fifo (
             .a_rst_i        (~rst_n),
             .wr_clk_i       (clk_cal),
             .rd_clk_i       (clk),
             .wr_en_i        (rdfifo_wr_en_w),
             .wdata          ({wr_fifo_rdata_2,wr_fifo_rdata}),
             .rd_en_i        (~rd_fifo_empty),
             .rdata          (rd_fifo_rdata),
             .rd_valid_o     (i_rdav_fifo),
             .full_o         (),
             .prog_full_o    (),
             .empty_o        (rd_fifo_empty)
         );
      end
      else begin
         `IP_MODULE_NAME(efx_fifo_top) #(
             .SYNC_CLK           (0),
             .OUTPUT_REG         (0),
             .MODE               ("STANDARD"),
             .PIPELINE_REG       (1),
             .OPTIONAL_FLAGS     (1),
             .PROGRAMMABLE_FULL  ("NONE"),
             .PROGRAMMABLE_EMPTY ("NONE"),
             .ASYM_WIDTH_RATIO   (4),
             .DATA_WIDTH         (RAM_DBW_TWO*2),
             .DEPTH              (16)
         ) rd_data_fifo (
             .a_rst_i        (~rst_n),
             .wr_clk_i       (clk_cal),
             .rd_clk_i       (clk),
             .wr_en_i        (rdfifo_wr_en),
             .wdata          (wr_fifo_rdata),
             .rd_en_i        (~rd_fifo_empty),
             .rdata          (rd_fifo_rdata),
             .rd_valid_o     (i_rdav_fifo),
             .full_o         (),
             .prog_full_o    (),
             .empty_o        (rd_fifo_empty)
         );
         end
     end
endgenerate
assign hbc_cs_n_en = (init_cs_n | ~init_flag) & (mcwr_cs_n | ~mcwr_flag) & (mcrd_cs_n | ~mcrd_flag); 
assign hbc_ck_en = (init_ck_en & init_flag) | (mcwr_ck_en & mcwr_flag) | (mcrd_ck_en & mcrd_flag);
always @ (*) begin
	if (!rst_n) begin hbc_cs_n           <=  1'b1; end
	else begin hbc_cs_n        <=  hbc_cs_n_en; end
end 
always @ (posedge clk or negedge rst_n)
begin
     if (!rst_n) begin
          hbc_ck_p_HI        <=  1'b0;
          hbc_ck_p_LO        <=  1'b0;
          hbc_ck_n_HI        <=  1'b0;
          hbc_ck_n_LO        <=  1'b0;
          hbc_rwds_OUT_HI <=  {RAM_DBW/8{1'b0}};
          hbc_rwds_OUT_LO <=  {RAM_DBW/8{1'b0}};
          hbc_rwds_OE       <=  {RAM_DBW/8{1'b0}};
          hbc_dq_OUT_HI   <=  {RAM_DBW{1'b0}};
          hbc_dq_OUT_LO   <=  {RAM_DBW{1'b0}};
          hbc_dq_OE       <=  {RAM_DBW{1'b0}};
     end
     else begin
          hbc_ck_p_HI     <=  hbc_ck_en;
          hbc_ck_p_LO     <=  1'b0;
          hbc_ck_n_HI     <=  1'b0;
          hbc_ck_n_LO     <=  hbc_ck_en;
          hbc_rwds_OUT_HI <=  mcwr_rwds_OUT_HI[(RAM_DBW/8)-1:0] & {RAM_DBW/8{mcwr_flag}};
          hbc_rwds_OUT_LO <=  mcwr_rwds_OUT_LO[(RAM_DBW/8)-1:0] & {RAM_DBW/8{mcwr_flag}};
          hbc_rwds_OE       <=  mcwr_rwds_OE & {RAM_DBW/8{mcwr_flag}};
          hbc_dq_OUT_HI   <=  (init_dq_OUT_HI & {RAM_DBW{init_flag}}) | (mcwr_dq_OUT_HI & {RAM_DBW{mcwr_flag}})  | (mcrd_dq_OUT_HI & {RAM_DBW{mcrd_flag}});
          hbc_dq_OUT_LO   <=  (init_dq_OUT_LO & {RAM_DBW{init_flag}}) | (mcwr_dq_OUT_LO & {RAM_DBW{mcwr_flag}})  | (mcrd_dq_OUT_LO & {RAM_DBW{mcrd_flag}});
          hbc_dq_OE       <=  (init_dq_OE & {RAM_DBW{init_flag}})     | (mcwr_dq_OE & {RAM_DBW{mcwr_flag}})      | (mcrd_dq_OE & {RAM_DBW{mcrd_flag}});
     end
end
generate
if (DUAL_RAM == 1) begin
	always @ (*) begin
		if (!rst_n) begin hbc_cs_n_2           <=  1'b1; end
		else begin hbc_cs_n_2        <=  hbc_cs_n_en;end
	end 
	always @ (posedge clk or negedge rst_n) begin
		 if (!rst_n) begin
			  hbc_ck_p_HI_2        <=  1'b0;
			  hbc_ck_p_LO_2        <=  1'b0;
			  hbc_ck_n_HI_2        <=  1'b0;
			  hbc_ck_n_LO_2        <=  1'b0;
			  hbc_rwds_OUT_HI_2 <=  {RAM_DBW/8{1'b0}};
			  hbc_rwds_OUT_LO_2 <=  {RAM_DBW/8{1'b0}};
			  hbc_rwds_OE_2       <=  {RAM_DBW/8{1'b0}};
			  hbc_dq_OUT_HI_2   <=  {RAM_DBW{1'b0}};
			  hbc_dq_OUT_LO_2   <=  {RAM_DBW{1'b0}};
			  hbc_dq_OE_2       <=  {RAM_DBW{1'b0}};
		 end
		 else begin
			  hbc_ck_p_HI_2     <=  hbc_ck_en;
			  hbc_ck_p_LO_2     <=  1'b0;
			  hbc_ck_n_HI_2     <=  1'b0;
			  hbc_ck_n_LO_2     <=  hbc_ck_en;
			  hbc_rwds_OUT_HI_2 <=  mcwr_rwds_OUT_HI[(RAM_DBW/8)-1:0] & {RAM_DBW/8{mcwr_flag}};
			  hbc_rwds_OUT_LO_2 <=  mcwr_rwds_OUT_LO & {RAM_DBW/8{mcwr_flag}};
			  hbc_rwds_OE_2       <=  mcwr_rwds_OE & {RAM_DBW/8{mcwr_flag}};
			  hbc_dq_OUT_HI_2   <=  (init_dq_OUT_HI & {RAM_DBW{init_flag}}) | (mcwr_dq_OUT_HI_2 & {RAM_DBW{mcwr_flag}})  | (mcrd_dq_OUT_HI & {RAM_DBW{mcrd_flag}});
			  hbc_dq_OUT_LO_2   <=  (init_dq_OUT_LO & {RAM_DBW{init_flag}}) | (mcwr_dq_OUT_LO_2 & {RAM_DBW{mcwr_flag}})  | (mcrd_dq_OUT_LO & {RAM_DBW{mcrd_flag}});
			  hbc_dq_OE_2       <=  (init_dq_OE & {RAM_DBW{init_flag}})     | (mcwr_dq_OE & {RAM_DBW{mcwr_flag}})      | (mcrd_dq_OE & {RAM_DBW{mcrd_flag}});
		 end
	end
end
endgenerate
`ifdef SIM
initial
begin
    ca[0] = 'h0;
    ca[1] = 'h0;
    ca[2] = 'h0;
    ca[3] = 'h0;
    ca[4] = 'h0;
    ca[5] = 'h0;
end
`endif
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end



`timescale 100ps/10ps


// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_cal_controller_top) #(
    parameter        CAL_MODE       = 0,
    parameter        CAL_BYTES      = 'h100,
    parameter        RAM_DBW        = 8,
    parameter        RAM_ABW        = 25,
    parameter        DQ_CAL_STEPS   = 8,
    parameter        DQ_DLY_W       = 3,
    parameter        RWDS_CAL_STEPS = 8,
    parameter        RWDS_DLY_W     = 3,
    parameter [15:0] CFG_CR0        = 0,
    parameter [3:0]  CR0_ILC        = 4'b0010,
    parameter [15:0] CFG_CR1        = 0,
    parameter [47:0] CR0W_CA        = 0,
    parameter [47:0] CR1W_CA        = 0,
    parameter        DQIN_MODE      = "",
    parameter        TCYC           = 10000,
    parameter        TCSM           = 4000000,
    parameter        TVCS           = 150000000,
    parameter        TRH            = 200000,
    parameter        TRTR           = 40000,
    parameter        PLL_MANUAL     = 0,
    parameter		 DUAL_RAM 		= 1,
    parameter		 INDIVI_DUAL_CAL 	= 1,
    parameter		 RAM_DBW_CAL 	= (DUAL_RAM == 1)? RAM_DBW *2 : RAM_DBW
) (
    input  wire                        clk, 
    input  wire                        clk_cal, 
    input  wire						   clk_cal_2, 
    input  wire                        rst_n, 
    input  wire                        calrst_n, 
    input  wire                        calrst_n_2, 
    input  wire                        h_rst_n, 
    input  wire                        h_ctc,
    output wire                        h_pause,
    output wire                        h_cal_en,
    input  wire                        h_req            , 
    input  wire                        h_last           , 
    input  wire [RAM_ABW-1:0]          h_addr           , 
    input  wire                        h_btype          , 
    input  wire                        h_atype          , 
    input  wire                        h_rwen           , 
    output reg                         h_mrdy, 
    input  wire [RAM_DBW_CAL/4-1:0]    h_wdm, 
    input  wire [RAM_DBW_CAL*2-1:0]    h_wdata, 
    output wire                        h_wrdy, 
    output wire [RAM_DBW_CAL*2-1:0]    h_rdata, 
    output wire                        h_rdav, 
    input  wire                        dyn_pll_phase_en,
    input  wire [RWDS_DLY_W-1:0]       dyn_pll_phase_sel,
    output wire [RWDS_DLY_W-1:0]       rwds_delay,
    output wire [RWDS_DLY_W-1:0]       rwds_delay_HI,
    output wire [RWDS_DLY_W-1:0]       rwds_delay_LO,
    output wire [DQ_DLY_W*RAM_DBW-1:0] dq_delay,
    output wire [26:0]                 debug_info, 
    input wire shift_done,
    output wire                        hbc_rst_n        , 
    output wire                        hbc_cs_n         , 
    output wire                        hbc_ck_p_HI      , 
    output wire                        hbc_ck_p_LO      , 
    output wire                        hbc_ck_n_HI      , 
    output wire                        hbc_ck_n_LO      , 
    output wire [RAM_DBW/8-1:0]        hbc_rwds_OUT_HI  , 
    output wire [RAM_DBW/8-1:0]        hbc_rwds_OUT_LO  , 
    input  wire [RAM_DBW/8-1:0]        hbc_rwds_IN_HI   , 
    input  wire [RAM_DBW/8-1:0]        hbc_rwds_IN_LO   , 
    input  wire [RAM_DBW/8-1:0]        hbc_rwds_IN_delay,
    output wire [RAM_DBW/8-1:0]        hbc_rwds_OE      , 
    output wire [RAM_DBW-1:0]          hbc_dq_OUT_HI    , 
    output wire [RAM_DBW-1:0]          hbc_dq_OUT_LO    , 
    input  wire [RAM_DBW-1:0]          hbc_dq_IN_HI     , 
    input  wire [RAM_DBW-1:0]          hbc_dq_IN_LO     , 
    output wire [RAM_DBW-1:0]          hbc_dq_OE,          
	output wire                 hbc_rst_n_2,
    output wire                 hbc_cs_n_2,
    output wire                 hbc_ck_p_HI_2,
    output wire                 hbc_ck_p_LO_2,
    output wire                 hbc_ck_n_HI_2,
    output wire                 hbc_ck_n_LO_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_HI_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_LO_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_HI_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_LO_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_delay_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OE_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_LO_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_HI_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_HI_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_LO_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OE_2
);
wire                 init_rdy;
wire                 cal_rstn;
wire                 cal_en;
wire                 cal_req;
wire                 cal_last;
wire [RAM_ABW-1:0]   cal_addr;
wire                 cal_rwen;
wire                 cal_wrdy;
wire                 cal_rdav;
wire                 mst_cal_done;
wire                 mst_cal_fail;
wire                 cal_done;
wire                 cal_fail;
wire [RAM_DBW_CAL*2-1:0] cal_wdata;
wire [RAM_DBW_CAL*2-1:0] cal_rdata;
`IP_MODULE_NAME(hbram_cal_ctrl) #(
    .CAL_MODE  (CAL_MODE),
    .RAM_DBW   (RAM_DBW),
    .RAM_ABW   (RAM_ABW),
    .CFG_CR0   (CFG_CR0),
    .CR0_ILC   (CR0_ILC),
    .CFG_CR1   (CFG_CR1),
    .CR0W_CA   (CR0W_CA),
    .CR1W_CA   (CR1W_CA),
    .DQIN_MODE (DQIN_MODE),
    .TCYC      (TCYC),
    .TCSM      (TCSM),
    .TVCS      (TVCS),
    .TRH       (TRH),
    .TRTR      (TRTR),
    .DUAL_RAM  (DUAL_RAM),
    .INDIVI_DUAL_CAL (INDIVI_DUAL_CAL)
) hbram_cal_ctrl_inst (
    .clk               (clk),
    .clk_cal           (clk_cal),
    .clk_cal_2		   (clk_cal_2),
    .rst_n             (rst_n),
    .calrst_n          (calrst_n),
    .calrst_n_2		   (calrst_n_2),
    .h_rst_n           (h_rst_n),
    .h_req             (h_req),
    .h_last            (h_last),
    .h_addr            (h_addr),
    .h_btype           (h_btype),
    .h_atype           (h_atype),
    .h_rwen            (h_rwen),
    .h_mrdy            (init_rdy),
    .h_wdm             (h_wdm),
    .h_wdata           (h_wdata),
    .h_wrdy            (h_wrdy),
    .h_rdata           (h_rdata),
    .h_rdav            (h_rdav),
    .h_ctc             (h_ctc),
    .h_pause           (h_pause),
    .cal_req           (cal_req),
    .cal_last          (cal_last),
    .cal_done          (cal_done),
    .cal_addr          (cal_addr),
    .cal_rwen          (cal_rwen),
    .cal_wdata         (cal_wdata),
    .cal_wrdy          (cal_wrdy),
    .cal_rdata         (cal_rdata),
    .cal_rdav          (cal_rdav),
    .mst_cal_done 	   (mst_cal_done),
    .hbc_rst_n         (hbc_rst_n),
    .hbc_cs_n          (hbc_cs_n),
    .hbc_ck_p_HI       (hbc_ck_p_HI),
    .hbc_ck_p_LO       (hbc_ck_p_LO),
    .hbc_ck_n_HI       (hbc_ck_n_HI),
    .hbc_ck_n_LO       (hbc_ck_n_LO),
    .hbc_rwds_OUT_HI   (hbc_rwds_OUT_HI),
    .hbc_rwds_OUT_LO   (hbc_rwds_OUT_LO),
    .hbc_rwds_IN_HI    (hbc_rwds_IN_HI),
    .hbc_rwds_IN_LO    (hbc_rwds_IN_LO),
    .hbc_rwds_IN_delay (hbc_rwds_IN_delay),
    .hbc_rwds_OE       (hbc_rwds_OE),
    .hbc_dq_OUT_HI     (hbc_dq_OUT_HI),
    .hbc_dq_OUT_LO     (hbc_dq_OUT_LO),
    .hbc_dq_IN_HI      (hbc_dq_IN_HI),
    .hbc_dq_IN_LO      (hbc_dq_IN_LO),
    .hbc_dq_OE         (hbc_dq_OE),
    .hbc_rst_n_2           (hbc_rst_n_2),
    .hbc_cs_n_2            (hbc_cs_n_2),
	.hbc_ck_p_HI_2         (hbc_ck_p_HI_2),
	.hbc_ck_p_LO_2         (hbc_ck_p_LO_2),
	.hbc_ck_n_HI_2         (hbc_ck_n_HI_2),
	.hbc_ck_n_LO_2         (hbc_ck_n_LO_2),
	.hbc_rwds_OUT_HI_2     (hbc_rwds_OUT_HI_2),
	.hbc_rwds_OUT_LO_2     (hbc_rwds_OUT_LO_2),
	.hbc_rwds_IN_HI_2      (hbc_rwds_IN_HI_2),
	.hbc_rwds_IN_LO_2      (hbc_rwds_IN_LO_2),
	.hbc_rwds_IN_delay_2   (hbc_rwds_IN_delay_2),
	.hbc_rwds_OE_2         (hbc_rwds_OE_2),
	.hbc_dq_OUT_HI_2       (hbc_dq_OUT_HI_2),
	.hbc_dq_OUT_LO_2       (hbc_dq_OUT_LO_2),
	.hbc_dq_IN_HI_2        (hbc_dq_IN_HI_2),
	.hbc_dq_IN_LO_2        (hbc_dq_IN_LO_2),
	.hbc_dq_OE_2           (hbc_dq_OE_2)
);
generate
    if (PLL_MANUAL) begin
        assign rwds_delay   = dyn_pll_phase_sel;
        assign h_cal_en     = dyn_pll_phase_en;
        assign cal_done     = init_rdy;
        assign cal_req      = 1'b0;
        assign cal_last     = 1'b0;
        assign cal_addr     = 'h0;
        assign cal_rwen     = 1'b0;
        assign cal_wdata    = 'h0;
        assign debug_info   = {11'd0,3'b0,2'd0};
        always@ (posedge clk) begin
            h_mrdy <= init_rdy;
        end
    end
    else begin
		always@ (posedge clk or negedge rst_n) begin
			if (!rst_n) begin
				h_mrdy <= 'd0;
			end else begin
				h_mrdy <= mst_cal_done & ~mst_cal_fail; 
			end
		end
        assign h_cal_en     = cal_en;
        `IP_MODULE_NAME(hbram_cal_mst) hbram_cal_mst_inst (
            .clk          (clk),
            .rst_n        (rst_n),
            .init_rdy     (init_rdy),
            .cal_rstn     (cal_rstn),
            .cal_en       (cal_en),
            .cal_done     (cal_done),
            .cal_fail     (cal_fail),
            .shift_done	(shift_done),
            .mst_cal_done (mst_cal_done),
            .mst_cal_fail (mst_cal_fail)
        );
        `IP_MODULE_NAME(hbram_cal_slv) #(
            .CAL_BYTES      (CAL_BYTES),
            .RAM_DBW        (RAM_DBW),
            .RAM_ABW        (RAM_ABW),
            .DQ_STEPS       (DQ_CAL_STEPS),
            .DQ_DLY_W       (DQ_DLY_W),
            .RWDS_STEPS     (RWDS_CAL_STEPS),
            .RWDS_DLY_W     (RWDS_DLY_W),
            .CAL_MODE		(CAL_MODE),
            .DUAL_RAM		(DUAL_RAM),
            .INDIVI_DUAL_CAL 	(INDIVI_DUAL_CAL)
        ) hbram_cal_slv_inst (
            .clk            	(clk),
            .rst_n          	(cal_rstn),
            .cal_req        	(cal_req),
            .cal_last       	(cal_last),
            .cal_done       	(cal_done),
            .cal_fail       	(cal_fail),
            .cal_addr       	(cal_addr),
            .cal_rwen       	(cal_rwen),
            .cal_wdata      	(cal_wdata),
            .cal_wrdy       	(cal_wrdy),
            .cal_rdata      	(cal_rdata),
            .cal_rdav       	(cal_rdav),
            .cal_en         	(cal_en),
            .cal_rwds_delay 	(rwds_delay),
            .cal_rwds_delay_HI 	(rwds_delay_HI),
            .cal_rwds_delay_LO 	(rwds_delay_LO),
            .cal_dq_delay   	(dq_delay),
            .cal_debug_info 	(debug_info)
        );
end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_cal_axi_top) #(
    parameter        RAM_DBW        = 8,
    parameter        RAM_ABW        = 32,
    parameter [15:0] CFG_CR0        = 0,
    parameter		 CR0_ILC		= 1'b1,
    parameter [15:0] CFG_CR1        = 0,
    parameter        AXI_IF         = 1,
    parameter        AXI_DBW        = 32,
    parameter        AXI_SBW        = AXI_DBW/8,
    parameter        AXI_AWR_DEPTH  = 16,
    parameter        AXI_W_DEPTH    = 256,
    parameter        AXI_R_DEPTH    = 256,
    parameter        DQIN_MODE      = "",
    parameter [4:0]  CAL_CLK_CH     = 5'b00001,
    parameter        CAL_MODE       = 2,
    parameter        CAL_DQ_STEPS   = 8,
    parameter        CAL_RWDS_STEPS = 8,
    parameter        CAL_BYTES      = 'h100,
    parameter        TCYC           = 100000,
    parameter        TCSM           = 4000000,
    parameter        TVCS           = 150000000,
    parameter        TRH            = 200000,
    parameter        TRTR           = 40000,
    parameter        RWDS_DLY_W     = $clog2(CAL_RWDS_STEPS),
    parameter        PLL_MANUAL     = 0,
    parameter		 DUAL_RAM		= 1,
    parameter		 INDIVI_DUAL_CAL		= 1,
    parameter [4:0]  CAL_CLK_CH_LO     = 5'b00001,
    parameter [4:0]  CAL_CLK_CH_HI     = 5'b00010
) (
    input  wire                 rst,
    input  wire                 ram_clk,
    input  wire                 ram_clk_cal,
    input  wire                 ram_clk_cal_2,
    input  wire                 io_axi_clk,
    input  wire                 io_arw_valid,
    input  wire [31:0]          io_arw_payload_addr,
    input  wire [7:0]           io_arw_payload_id,
    input  wire [7:0]           io_arw_payload_len,
    input  wire [2:0]           io_arw_payload_size,
    input  wire [1:0]           io_arw_payload_burst,
    input  wire [1:0]           io_arw_payload_lock,
    input  wire                 io_arw_payload_write,
    output wire                 io_arw_ready,
    input  wire [7:0]           io_w_payload_id,
    input  wire                 io_w_valid,
    input  wire [AXI_DBW-1:0]   io_w_payload_data,
    input  wire [AXI_SBW-1:0]   io_w_payload_strb,
    input  wire                 io_w_payload_last,
    output wire                 io_w_ready,
    input  wire                 io_b_ready,
    output wire                 io_b_valid,
    output wire [7:0]           io_b_payload_id,
    input  wire                 io_r_ready,
    output wire                 io_r_valid,
    output wire [AXI_DBW-1:0]   io_r_payload_data,
    output wire [7:0]           io_r_payload_id,
    output wire [1:0]           io_r_payload_resp,
    output wire                 io_r_payload_last,
    input  wire                 native_ram_rdwr,
    input  wire                 native_ram_en,
    input  wire [AXI_DBW-1:0]   native_wr_data,
    input  wire [AXI_SBW-1:0]   native_wr_datamask,
    input  wire [31:0]          native_wr_address,
    input  wire                 native_wr_en,
    input  wire [10:0]          native_wr_burst_len,
    output wire                 native_wr_buf_ready,
    output wire [AXI_DBW-1:0]   native_rd_data,
    output wire                 native_rd_valid,
    output wire                 native_ctrl_idle,
    input  wire                 dyn_pll_phase_en,
    input  wire [2:0]           dyn_pll_phase_sel,
    output wire                 hbc_cal_SHIFT_ENA,
    output wire [2:0]           hbc_cal_SHIFT,
    output wire [2:0]           hbc_cal_SHIFT_HI,
    output wire [2:0]           hbc_cal_SHIFT_LO,
    output wire [4:0]           hbc_cal_SHIFT_SEL,
    output wire [26:0]          hbc_cal_debug_info,
    output wire                 hbc_rst_n,
    output wire                 hbc_cs_n,
    output wire                 hbc_ck_p_HI,
    output wire                 hbc_ck_p_LO,
    output wire                 hbc_ck_n_HI,
    output wire                 hbc_ck_n_LO,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_HI,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_LO,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_HI,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_LO,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OE,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_HI,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_LO,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_HI,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_LO,
    output wire [RAM_DBW-1:0]   hbc_dq_OE,
	output wire                 hbc_rst_n_2,
    output wire                 hbc_cs_n_2,
    output wire                 hbc_ck_p_HI_2,
    output wire                 hbc_ck_p_LO_2,
    output wire                 hbc_ck_n_HI_2,
    output wire                 hbc_ck_n_LO_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_HI_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OUT_LO_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_HI_2,
    input  wire [RAM_DBW/8-1:0] hbc_rwds_IN_LO_2,
    output wire [RAM_DBW/8-1:0] hbc_rwds_OE_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_LO_2,
    input  wire [RAM_DBW-1:0]   hbc_dq_IN_HI_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_HI_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OUT_LO_2,
    output wire [RAM_DBW-1:0]   hbc_dq_OE_2,
    output wire                 hbc_cal_pass
);
localparam DQ_DLY_W       = $clog2(CAL_DQ_STEPS);
localparam [47:0] CR0W_CA = {8'h00, 8'h00, 8'h00, 8'h01, 8'h00, 8'h60};
localparam [47:0] CR1W_CA = {8'h01, 8'h00, 8'h00, 8'h01, 8'h00, 8'h60};
localparam RAM_DBW_TWO = (DUAL_RAM == 1)? RAM_DBW*2 : RAM_DBW;
wire                        h_cal_en;
wire                        h_req;
wire                        h_last;
wire [RAM_ABW-1:0]          h_addr;
wire                        h_btype;
wire                        h_atype;
wire                        h_rwen;
wire                        h_mrdy;
wire [RAM_DBW_TWO/4-1:0]        h_wdm;
wire [RAM_DBW_TWO*2-1:0]        h_wdata;
wire                        h_wrdy;
wire [RAM_DBW_TWO*2-1:0]        h_rdata;
wire                        h_rdav;
wire                        h_ctc;
wire                        h_pause;
wire                        io_axi_rstn;
wire                        ram_rstn;
wire [RWDS_DLY_W-1:0]       rwds_delay_w;
wire [RWDS_DLY_W-1:0]       rwds_delay_w_HI;
wire [RWDS_DLY_W-1:0]       rwds_delay_w_LO;
wire [DQ_DLY_W*RAM_DBW-1:0] dq_delay_w;
wire 						io_axi_rst_w;
wire 						ram_rst_w;
wire 						ramcal_rst_w;
wire 						ramcal_rst_w2;
wire [4:0] 					hbc_cal_SHIFT_SEL_user;
(* async_reg = "true" *) reg  [2:0]                  axi_rst_sync;
(* async_reg = "true" *) reg  [2:0]                  ram_rst_sync;
(* async_reg = "true" *) reg  [2:0]                 ramcal_rst_sync;
(* async_reg = "true" *) reg  [2:0]                 ramcal_rst_sync_2;
reg  [RWDS_DLY_W-1:0]       hbc_rwds_delay;
reg  [RWDS_DLY_W-1:0]       hbc_rwds_delay_HI;
reg  [RWDS_DLY_W-1:0]       hbc_rwds_delay_LO;
reg  [DQ_DLY_W*RAM_DBW-1:0] hbc_dq_delay ;
reg [4:0] shift_clk_cnt;
reg shift_done;
`IP_MODULE_NAME(efx_resetsync) #(
	.ASYNC_STAGE 	(2),
	.ACTIVE_LOW 	(0)
) axi_rst_syncronizer (
	.clk 	(io_axi_clk),
	.reset 	(rst),
	.d_o 	(io_axi_rst_w)
);
assign io_axi_rstn = ~io_axi_rst_w;
`IP_MODULE_NAME(efx_resetsync) #(
	.ASYNC_STAGE 	(2),
	.ACTIVE_LOW 	(0)
) ram_rst_syncronizer (
	.clk 	(ram_clk),
	.reset 	(rst),
	.d_o 	(ram_rst_w)
);
assign ram_rstn = ~ram_rst_w;
`IP_MODULE_NAME(efx_resetsync) #(
	.ASYNC_STAGE 	(2),
	.ACTIVE_LOW 	(0)
) ramcal_rst_syncronizer (
	.clk 	(ram_clk_cal),
	.reset 	(rst),
	.d_o 	(ramcal_rst_w)
);
assign ramcal_rstn = ~ramcal_rst_w;
`IP_MODULE_NAME(efx_resetsync) #(
	.ASYNC_STAGE 	(2),
	.ACTIVE_LOW 	(0)
) ramcal_rst_syncronizer_2 (
	.clk 	(ram_clk_cal_2),
	.reset 	(rst),
	.d_o 	(ramcal_rst_w2)
);
assign ramcal_rstn_2 = ~ramcal_rst_w2;
assign hbc_cal_pass = h_mrdy;
wire shift_done_w;
assign shift_done_w = shift_done;
reg shift_ena;
always @ (posedge ram_clk or posedge ram_rst_w) begin
	if (ram_rst_w) begin
		shift_done <= 0;
	end
	else if (shift_clk_cnt == 'd13) begin
		shift_done <= 1;
	end
	else begin
		shift_done <= shift_done;
	end
end
always @ (posedge ram_clk or posedge ram_rst_w) begin
	if (ram_rst_w) begin
		shift_clk_cnt <= 0;
	end
	else if (shift_clk_cnt == 'b11111 ) begin
		shift_clk_cnt <= shift_clk_cnt;
	end
	else if (hbc_cal_debug_info[0]) begin
		shift_clk_cnt <= shift_clk_cnt + 1'b1;
	end
end
always @ (posedge ram_clk or posedge ram_rst_w) begin
	if (ram_rst_w) begin
		shift_ena <= 0;
	end
	else if ((shift_clk_cnt > 'd4 && shift_clk_cnt < 'd13) || (shift_clk_cnt > 'd16 && shift_clk_cnt < 'd25)) begin 
		shift_ena <= 1;
	end
	else begin
		shift_ena <= 0;
	end
end
generate
if (DUAL_RAM == 1 && INDIVI_DUAL_CAL == 1) begin
	always@(posedge ram_clk or negedge ram_rstn) begin
		if (!ram_rstn) begin
			hbc_rwds_delay_HI <= 'b0;
			hbc_rwds_delay_LO <= 'b0;
		end
		else begin
			hbc_rwds_delay_HI <= rwds_delay_w_HI;
			hbc_rwds_delay_LO <= rwds_delay_w_LO;
		end
	end
	assign hbc_cal_SHIFT_ENA 		= (hbc_cal_debug_info[0])? shift_ena:h_cal_en;
	assign hbc_cal_SHIFT     		= (shift_done)? hbc_rwds_delay_LO : hbc_rwds_delay_HI;
	assign hbc_cal_SHIFT_SEL 		= (~hbc_cal_debug_info[0])? (CAL_CLK_CH_HI|CAL_CLK_CH_LO) : hbc_cal_SHIFT_SEL_user;
	assign hbc_cal_SHIFT_SEL_user 	= (shift_done)? CAL_CLK_CH_HI : CAL_CLK_CH_LO;
	assign hbc_cal_SHIFT_HI     	= hbc_rwds_delay_HI;
	assign hbc_cal_SHIFT_LO    	 	= hbc_rwds_delay_LO;
end
else begin
	always@(posedge ram_clk)
	begin
		hbc_rwds_delay <= rwds_delay_w;
		hbc_dq_delay   <= dq_delay_w;
	end
	assign hbc_cal_SHIFT_ENA = h_cal_en;
	assign hbc_cal_SHIFT     = hbc_rwds_delay;
	assign hbc_cal_SHIFT_SEL = CAL_CLK_CH;
end
endgenerate
generate
    if (AXI_IF) begin
        `IP_MODULE_NAME(hbram_axi_wrapper) #(
            .RAM_DBW       (RAM_DBW),
            .RAM_ABW       (RAM_ABW),
            .AXI_DBW       (AXI_DBW),
            .AXI_AWR_DEPTH (AXI_AWR_DEPTH),
            .AXI_W_DEPTH   (AXI_W_DEPTH),
            .AXI_R_DEPTH   (AXI_R_DEPTH),
            .DUAL_RAM		(DUAL_RAM)
        ) hbram_axi_wrapper_inst (
            .ram_clk               (ram_clk),
            .ram_rstn              (ram_rstn),
            .io_axi_clk            (io_axi_clk),
            .io_axi_rstn           (io_axi_rstn),
            .io_arw_valid          (io_arw_valid),
            .io_arw_ready          (io_arw_ready),
            .io_arw_payload_addr   (io_arw_payload_addr),
            .io_arw_payload_id     (io_arw_payload_id),
            .io_arw_payload_len    (io_arw_payload_len),
            .io_arw_payload_size   (io_arw_payload_size),
            .io_arw_payload_burst  (io_arw_payload_burst),
            .io_arw_payload_write  (io_arw_payload_write),
            .io_w_payload_id       (io_w_payload_id),
            .io_w_valid            (io_w_valid),
            .io_w_ready            (io_w_ready),
            .io_w_payload_data     (io_w_payload_data),
            .io_w_payload_strb     (io_w_payload_strb),
            .io_w_payload_last     (io_w_payload_last),
            .io_b_valid            (io_b_valid),
            .io_b_ready            (io_b_ready),
            .io_b_payload_id       (io_b_payload_id),
            .io_r_valid            (io_r_valid),
            .io_r_ready            (io_r_ready),
            .io_r_payload_data     (io_r_payload_data),
            .io_r_payload_id       (io_r_payload_id),
            .io_r_payload_resp     (io_r_payload_resp),
            .io_r_payload_last     (io_r_payload_last),
            .h_ctc                 (h_ctc),
            .h_pause               (h_pause),
            .h_req                 (h_req),
            .h_last                (h_last),
            .h_addr                (h_addr),
            .h_btype               (h_btype),
            .h_atype               (h_atype),
            .h_rwen                (h_rwen),
            .h_mrdy                (h_mrdy),
            .h_wdm                 (h_wdm),
            .h_wdata               (h_wdata),
            .h_wrdy                (h_wrdy),
            .h_rdata               (h_rdata),
            .h_rdav                (h_rdav)
        );
    end
    else begin
        `IP_MODULE_NAME(hbram_native_if) # (
            .USER_DBW          (AXI_DBW),
            .USER_WFD          (AXI_W_DEPTH),
            .USER_RFD          (AXI_R_DEPTH),
            .RAM_DBW           (RAM_DBW),
            .RAM_ABW           (RAM_ABW)
        ) hbram_native_if_inst (
            .user_clk          (io_axi_clk),
            .user_rst_n        (io_axi_rstn),
            .ram_clk           (ram_clk),
            .ram_rst_n         (ram_rstn),
            .user_ram_rdwr     (native_ram_rdwr),
            .user_ram_en       (native_ram_en),
            .user_wr_data      (native_wr_data),
            .user_wr_burst_len (native_wr_burst_len),
            .user_wr_datamask  (native_wr_datamask),
            .user_wr_address   (native_wr_address),
            .user_wr_en        (native_wr_en),
            .user_wr_buf_ready (native_wr_buf_ready),
            .user_rd_data      (native_rd_data),
            .user_rd_valid     (native_rd_valid),
            .ctrl_idle         (native_ctrl_idle),
            .h_ready           (hbc_cal_pass ),
            .h_ctc             (h_ctc),
            .h_pause           (h_pause),
            .h_req             (h_req),
            .h_last            (h_last),
            .h_addr            (h_addr),
            .h_btype           (h_btype),
            .h_atype           (h_atype),
            .h_rwen            (h_rwen),
            .h_mrdy            (h_mrdy),
            .h_wdm             (h_wdm),
            .h_wdata           (h_wdata),
            .h_wrdy            (h_wrdy),
            .h_rdata           (h_rdata),
            .h_rdav            (h_rdav)
        );
    end
endgenerate
generate
wire [RAM_DBW-1:0]   hbc_dq_IN_delay;
wire [RAM_DBW-1:0]   hbc_dq_IN_LO_ddio;
wire [RAM_DBW-1:0]   hbc_dq_IN_HI_ddio;
wire [RAM_DBW/8-1:0] int_rwds_IN_delay;
if (CAL_MODE == 3) begin
    `IP_MODULE_NAME(hbram_cal_controller_top) #(
        .CAL_MODE       (CAL_MODE),
        .CAL_BYTES      (CAL_BYTES),
        .RAM_DBW        (RAM_DBW),
        .RAM_ABW        (RAM_ABW),
        .CFG_CR0        (CFG_CR0),
        .CR0_ILC		(CR0_ILC),
        .CFG_CR1        (CFG_CR1),
        .CR0W_CA        (CR0W_CA),
        .CR1W_CA        (CR1W_CA),
        .DQIN_MODE      (DQIN_MODE),
        .TCYC           (TCYC),
        .TCSM           (TCSM),
        .TVCS           (TVCS),
        .TRH            (TRH),
        .TRTR           (TRTR),
        .DQ_CAL_STEPS   (CAL_DQ_STEPS),
        .DQ_DLY_W       (DQ_DLY_W),
        .RWDS_CAL_STEPS (CAL_RWDS_STEPS),
        .RWDS_DLY_W     (RWDS_DLY_W),
        .PLL_MANUAL     (1),
        .DUAL_RAM		(DUAL_RAM),
        .INDIVI_DUAL_CAL		(INDIVI_DUAL_CAL)
    ) hbram_cal_top_inst (
        .clk               (ram_clk),
        .clk_cal           (ram_clk_cal),
        .clk_cal_2		   (ram_clk_cal_2),
        .rst_n             (ram_rstn),
        .calrst_n          (ramcal_rstn),
        .calrst_n_2        (ramcal_rstn_2),
        .h_rst_n           (ram_rstn),
        .h_cal_en          (h_cal_en),
        .h_ctc             (h_ctc),
        .h_pause           (h_pause),
        .h_req             (h_req),
        .h_last            (h_last),
        .h_addr            (h_addr),
        .h_btype           (h_btype),
        .h_atype           (h_atype),
        .h_rwen            (h_rwen),
        .h_mrdy            (h_mrdy),
        .h_wdm             (h_wdm),
        .h_wdata           (h_wdata),
        .h_wrdy            (h_wrdy),
        .h_rdata           (h_rdata),
        .h_rdav            (h_rdav),
        .dyn_pll_phase_en  (dyn_pll_phase_en),
        .dyn_pll_phase_sel (dyn_pll_phase_sel),
        .rwds_delay        (rwds_delay_w),
        .dq_delay          (dq_delay_w),
        .debug_info        (hbc_cal_debug_info),
        .hbc_rst_n         (hbc_rst_n),
        .hbc_cs_n          (hbc_cs_n),
        .hbc_ck_p_HI       (hbc_ck_p_HI),
        .hbc_ck_p_LO       (hbc_ck_p_LO),
        .hbc_ck_n_HI       (hbc_ck_n_HI),
        .hbc_ck_n_LO       (hbc_ck_n_LO),
        .hbc_rwds_OUT_HI   (hbc_rwds_OUT_HI),
        .hbc_rwds_OUT_LO   (hbc_rwds_OUT_LO),
        .hbc_rwds_IN_HI    (hbc_rwds_IN_HI),
        .hbc_rwds_IN_LO    (hbc_rwds_IN_LO),
        .hbc_rwds_IN_delay (),
        .hbc_rwds_OE       (hbc_rwds_OE),
        .hbc_dq_OUT_HI     (hbc_dq_OUT_HI),
        .hbc_dq_OUT_LO     (hbc_dq_OUT_LO),
        .hbc_dq_IN_HI      (hbc_dq_IN_HI),
        .hbc_dq_IN_LO      (hbc_dq_IN_LO),
        .hbc_dq_OE         (hbc_dq_OE)
    );
end
else if (CAL_MODE == 1) begin
    `IP_MODULE_NAME(hbram_cal_controller_top) #(
        .CAL_MODE       (CAL_MODE),
        .CAL_BYTES      (CAL_BYTES),
        .RAM_DBW        (RAM_DBW),
        .RAM_ABW        (RAM_ABW),
        .CFG_CR0        (CFG_CR0),
        .CR0_ILC		(CR0_ILC),
        .CFG_CR1        (CFG_CR1),
        .CR0W_CA        (CR0W_CA),
        .CR1W_CA        (CR1W_CA),
        .DQIN_MODE      (DQIN_MODE),
        .TCYC           (TCYC),
        .TCSM           (TCSM),
        .TVCS           (TVCS),
        .TRH            (TRH),
        .TRTR           (TRTR),
        .DQ_CAL_STEPS   (CAL_DQ_STEPS),
        .DQ_DLY_W       (DQ_DLY_W),
        .RWDS_CAL_STEPS (CAL_RWDS_STEPS),
        .RWDS_DLY_W     (RWDS_DLY_W        ),
        .DUAL_RAM		(DUAL_RAM),
        .INDIVI_DUAL_CAL		(INDIVI_DUAL_CAL)
    ) hbram_cal_top_inst (
        .clk                  (ram_clk),
        .rst_n                (ram_rstn),
        .calrst_n             (ramcal_rstn),
        .h_rst_n              (ram_rstn),
        .h_cal_en             (h_cal_en),
        .h_ctc                (h_ctc),
        .h_pause              (h_pause),
        .h_req                (h_req),
        .h_last               (h_last),
        .h_addr               (h_addr),
        .h_btype              (h_btype),
        .h_atype              (h_atype),
        .h_rwen               (h_rwen),
        .h_mrdy               (h_mrdy),
        .h_wdm                (h_wdm),
        .h_wdata              (h_wdata),
        .h_wrdy               (h_wrdy),
        .h_rdata              (h_rdata),
        .h_rdav               (h_rdav),
        .rwds_delay           (rwds_delay_w),
        .dq_delay             (dq_delay_w),
        .debug_info           (hbc_cal_debug_info),
        .hbc_rst_n            (hbc_rst_n),
        .hbc_cs_n             (hbc_cs_n),
        .hbc_ck_p_HI          (hbc_ck_p_HI),
        .hbc_ck_p_LO          (hbc_ck_p_LO),
        .hbc_ck_n_HI          (hbc_ck_n_HI),
        .hbc_ck_n_LO          (hbc_ck_n_LO),
        .hbc_rwds_OUT_HI      (hbc_rwds_OUT_HI),
        .hbc_rwds_OUT_LO      (hbc_rwds_OUT_LO),
        .hbc_rwds_IN_HI       (hbc_rwds_IN_HI),
        .hbc_rwds_IN_LO       (),
        .hbc_rwds_IN_delay    (int_rwds_IN_delay),
        .hbc_rwds_OE          (hbc_rwds_OE),
        .hbc_dq_OUT_HI        (hbc_dq_OUT_HI),
        .hbc_dq_OUT_LO        (hbc_dq_OUT_LO),
        .hbc_dq_IN_HI         (hbc_dq_IN_HI_ddio),
        .hbc_dq_IN_LO         (hbc_dq_IN_LO_ddio),
        .hbc_dq_OE            (hbc_dq_OE            ),
        .hbc_rst_n_2          (hbc_rst_n_2),
    	.hbc_cs_n_2           (hbc_cs_n_2),
		.hbc_ck_p_HI_2        (hbc_ck_p_HI_2),
		.hbc_ck_p_LO_2        (hbc_ck_p_LO_2),
		.hbc_ck_n_HI_2        (hbc_ck_n_HI_2),
		.hbc_ck_n_LO_2        (hbc_ck_n_LO_2),
		.hbc_rwds_OUT_HI_2    (hbc_rwds_OUT_HI_2),
		.hbc_rwds_OUT_LO_2    (hbc_rwds_OUT_LO_2),
		.hbc_rwds_IN_HI_2     (hbc_rwds_IN_HI_2),
		.hbc_rwds_IN_LO_2     (hbc_rwds_IN_LO_2),
		.hbc_rwds_OE_2        (hbc_rwds_OE_2),
		.hbc_dq_OUT_HI_2      (hbc_dq_OUT_HI_2),
		.hbc_dq_OUT_LO_2      (hbc_dq_OUT_LO_2),
		.hbc_dq_IN_HI_2       (hbc_dq_IN_HI_2),
		.hbc_dq_IN_LO_2       (hbc_dq_IN_LO_2),
		.hbc_dq_OE_2          (hbc_dq_OE_2)
    );
    genvar i,j,k;
    `ifndef SIM
    for (i=0; i< RAM_DBW/8; i=i+1) begin
        `IP_MODULE_NAME(mux_delay) mux_delay_rwd (
            .in  (hbc_rwds_IN_HI[i]),
            .s   (hbc_rwds_delay),
            .out (int_rwds_IN_delay[i]),
            .clk (ram_clk)
        );
    end
    for (j=0; j<RAM_DBW; j=j+1) begin
        `IP_MODULE_NAME(mux_delay) mux_delay_dq (
            .in  (hbc_dq_IN_HI[j]),
            .s   (hbc_dq_delay[(j*$clog2(CAL_DQ_STEPS))+:$clog2(CAL_DQ_STEPS)]),
            .out (hbc_dq_IN_delay[j]),
            .clk (ram_clk)
        );
    end
    for (k=0; k< RAM_DBW/8; k=k+1) begin
    `IP_MODULE_NAME(soft_iddio) #(
        .MODE (DQIN_MODE)
    ) dq_iddio_inst (
          .clk         (int_rwds_IN_delay[k]),
          .ddr_din     (hbc_dq_IN_delay  [k*8+7 -: 8]),
          .ddr_din_HI  (hbc_dq_IN_HI_ddio[k*8+7 -: 8]),
          .ddr_din_LO  (hbc_dq_IN_LO_ddio[k*8+7 -: 8])
    );
    end
    `else
    for (k=0; k< RAM_DBW/8; k=k+1) begin
    `IP_MODULE_NAME(soft_iddio) #(
        .MODE (DQIN_MODE)
    ) dq_iddio_inst (
        .clk         (hbc_rwds_IN_HI[k]),
        .ddr_din     (hbc_dq_IN_HI[k*8+7 -: 8]),
        .ddr_din_HI  (hbc_dq_IN_HI_ddio[k*8+7 -: 8]),
        .ddr_din_LO  (hbc_dq_IN_LO_ddio[k*8+7 -: 8])
    );
    assign int_rwds_IN_delay[k] = hbc_rwds_IN_HI[k];
    end
    `endif
end
else if (CAL_MODE == 2) begin
    `IP_MODULE_NAME(hbram_cal_controller_top) #(
        .CAL_MODE       (CAL_MODE),
        .CAL_BYTES      (CAL_BYTES),
        .RAM_DBW        (RAM_DBW),
        .RAM_ABW        (RAM_ABW),
        .CFG_CR0        (CFG_CR0),
        .CR0_ILC		(CR0_ILC),
        .CFG_CR1        (CFG_CR1),
        .CR0W_CA        (CR0W_CA),
        .CR1W_CA        (CR1W_CA),
        .DQIN_MODE      (DQIN_MODE),
        .TCYC           (TCYC),
        .TCSM           (TCSM),
        .TVCS           (TVCS),
        .TRH            (TRH),
        .TRTR           (TRTR),
        .DQ_CAL_STEPS   (CAL_DQ_STEPS),
        .DQ_DLY_W       (DQ_DLY_W),
        .RWDS_CAL_STEPS (CAL_RWDS_STEPS),
        .RWDS_DLY_W     (RWDS_DLY_W),
        .PLL_MANUAL     (0),
        .DUAL_RAM		(DUAL_RAM),
        .INDIVI_DUAL_CAL		(INDIVI_DUAL_CAL)
    ) hbram_cal_top_inst (
        .clk               (ram_clk),
        .clk_cal           (ram_clk_cal),
        .clk_cal_2		   (ram_clk_cal_2),
        .rst_n             (ram_rstn),
        .calrst_n          (ramcal_rstn),
        .calrst_n_2        (ramcal_rstn_2),
        .h_rst_n           (ram_rstn),
        .h_cal_en          (h_cal_en),
        .h_ctc             (h_ctc),
        .h_pause           (h_pause),
        .h_req             (h_req),
        .h_last            (h_last),
        .h_addr            (h_addr),
        .h_btype           (h_btype),
        .h_atype           (h_atype),
        .h_rwen            (h_rwen),
        .h_mrdy            (h_mrdy),
        .h_wdm             (h_wdm),
        .h_wdata           (h_wdata),
        .h_wrdy            (h_wrdy),
        .h_rdata           (h_rdata),
        .h_rdav            (h_rdav),
        .dyn_pll_phase_en  (dyn_pll_phase_en),
        .dyn_pll_phase_sel (dyn_pll_phase_sel),
        .rwds_delay        (rwds_delay_w),
        .rwds_delay_HI     (rwds_delay_w_HI),
        .rwds_delay_LO     (rwds_delay_w_LO),
        .dq_delay          (dq_delay_w),
        .debug_info        (hbc_cal_debug_info),
        .shift_done		   (shift_done_w),
        .hbc_rst_n         (hbc_rst_n),
        .hbc_cs_n          (hbc_cs_n),
        .hbc_ck_p_HI       (hbc_ck_p_HI),
        .hbc_ck_p_LO       (hbc_ck_p_LO),
        .hbc_ck_n_HI       (hbc_ck_n_HI),
        .hbc_ck_n_LO       (hbc_ck_n_LO),
        .hbc_rwds_OUT_HI   (hbc_rwds_OUT_HI),
        .hbc_rwds_OUT_LO   (hbc_rwds_OUT_LO),
        .hbc_rwds_IN_HI    (hbc_rwds_IN_HI),
        .hbc_rwds_IN_LO    (hbc_rwds_IN_LO),
        .hbc_rwds_IN_delay (),
        .hbc_rwds_OE       (hbc_rwds_OE),
        .hbc_dq_OUT_HI     (hbc_dq_OUT_HI),
        .hbc_dq_OUT_LO     (hbc_dq_OUT_LO),
        .hbc_dq_IN_HI      (hbc_dq_IN_HI),
        .hbc_dq_IN_LO      (hbc_dq_IN_LO),
        .hbc_dq_OE         (hbc_dq_OE),
        .hbc_rst_n_2          (hbc_rst_n_2),
    	.hbc_cs_n_2            (hbc_cs_n_2),
		.hbc_ck_p_HI_2         (hbc_ck_p_HI_2),
		.hbc_ck_p_LO_2         (hbc_ck_p_LO_2),
		.hbc_ck_n_HI_2         (hbc_ck_n_HI_2),
		.hbc_ck_n_LO_2         (hbc_ck_n_LO_2),
		.hbc_rwds_OUT_HI_2     (hbc_rwds_OUT_HI_2),
		.hbc_rwds_OUT_LO_2     (hbc_rwds_OUT_LO_2),
		.hbc_rwds_IN_HI_2      (hbc_rwds_IN_HI_2),
		.hbc_rwds_IN_LO_2      (hbc_rwds_IN_LO_2),
		.hbc_rwds_IN_delay_2   (),
		.hbc_rwds_OE_2         (hbc_rwds_OE_2),
		.hbc_dq_OUT_HI_2       (hbc_dq_OUT_HI_2),
		.hbc_dq_OUT_LO_2       (hbc_dq_OUT_LO_2),
		.hbc_dq_IN_HI_2        (hbc_dq_IN_HI_2),
		.hbc_dq_IN_LO_2        (hbc_dq_IN_LO_2),
		.hbc_dq_OE_2           (hbc_dq_OE_2)
    );
end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(hbram_axi_wrapper) #(
    parameter RAM_DBW       = 8,
    parameter RAM_2DBW      = RAM_DBW * 2,
    parameter RAM_DMW       = RAM_2DBW / 8,
    parameter RAM_ABW       = 25,
    parameter AXI_DBW       = 16,
    parameter AXI_SBW       = AXI_DBW / 8,
    parameter AXI_AWR_DEPTH = 16,
    parameter AXI_W_DEPTH   = 256,
    parameter AXI_R_DEPTH   = 256,
    parameter DUAL_RAM 		= 1,
    parameter RAM_DBW_TWO   = (DUAL_RAM == 1)? RAM_DBW*4 : RAM_DBW * 2,
    parameter RAM_DMW_TWO   = RAM_DBW_TWO / 8,
    parameter D_RATIO       = AXI_DBW / RAM_DBW_TWO
) (
    input  wire               ram_clk,
    input  wire               ram_rstn,
    input  wire               io_axi_clk,
    input  wire               io_axi_rstn,
    input  wire               io_arw_valid,
    input  wire [31:0]        io_arw_payload_addr,
    input  wire [7:0]         io_arw_payload_id,
    input  wire [7:0]         io_arw_payload_len,
    input  wire [2:0]         io_arw_payload_size,
    input  wire [1:0]         io_arw_payload_burst,
    input  wire               io_arw_payload_write,
    output wire               io_arw_ready,
    input  wire [7:0]         io_w_payload_id,
    input  wire               io_w_valid,
    input  wire [AXI_DBW-1:0] io_w_payload_data,
    input  wire [AXI_SBW-1:0] io_w_payload_strb,
    input  wire               io_w_payload_last,
    output wire               io_w_ready,
    input  wire               io_b_ready,
    output wire               io_b_valid,
    output wire [7:0]         io_b_payload_id,
    input  wire               io_r_ready,
    output wire               io_r_valid,
    output wire [AXI_DBW-1:0] io_r_payload_data,
    output wire [7:0]         io_r_payload_id,
    output wire [1:0]         io_r_payload_resp,
    output wire               io_r_payload_last,
    input  wire                h_wrdy,
    input  wire                h_mrdy,
    input  wire [RAM_DBW_TWO-1:0] h_rdata,
    input  wire                h_rdav,
    input  wire                h_pause,
    output wire                h_rwen,
    output wire                h_req,
    output wire [31:0]         h_addr,
    output wire [RAM_DBW_TWO-1:0] h_wdata,
    output wire [RAM_DMW_TWO-1:0]  h_wdm,
    output wire                h_last,
    output wire                h_ctc,
    output wire                h_btype,
    output wire                h_atype
);
wire                s_ax_type;
wire [7:0]          s_ax_id;
wire [7:0]          s_ax_len;
wire [2:0]          s_ax_size;
wire [1:0]          s_ax_burst;
wire [31:0]         s_ax_addr;
wire                s_ax_valid;
wire                s_ax_ready;
wire                s_w_valid;
wire [RAM_DBW_TWO-1:0] s_w_data;
wire [RAM_DMW_TWO-1:0]  s_w_strb;
wire                s_w_last;
wire                s_w_ready;
wire [7:0]          s_b_id;
wire [1:0]          s_b_resp;
wire                s_b_valid;
wire                s_b_ready;
wire                s_r_valid;
wire [RAM_DBW_TWO-1:0] s_r_data;
wire [7:0]          s_r_id;
wire [1:0]          s_r_resp;
wire                s_r_last;
wire                s_r_ready;
wire h_mrdy_sync;
wire ax_ready;
localparam CTRL_DBW2 = (DUAL_RAM == 1)? RAM_2DBW*2 : RAM_2DBW;
assign io_arw_ready = h_mrdy_sync & ax_ready;
`IP_MODULE_NAME(efx_asyncreg) # (
    .ASYNC_STAGE (2),
    .WIDTH (1),
    .ACTIVE_LOW (1)
) xh_mrdy (
    .clk    	(io_axi_clk),
    .reset_n    (io_axi_rstn),
    .d_i  		(h_mrdy),
    .d_o 		(h_mrdy_sync)
);
`IP_MODULE_NAME(efx_axi_amux_top) #(
    .CTRL_DBW      (CTRL_DBW2),
    .AXI_DBW       (AXI_DBW),
    .AXI_SBW       (AXI_SBW),
    .AXI_AWR_DEPTH (AXI_AWR_DEPTH),
    .AXI_W_DEPTH   (AXI_W_DEPTH),
    .AXI_R_DEPTH   (AXI_R_DEPTH),
    .DUAL_RAM	   (DUAL_RAM)
) xefx_axi_amux_top (
    .axi_clk    (io_axi_clk),
    .axi_rst_n  (io_axi_rstn),
    .ctrl_clk   (ram_clk),
    .ctrl_rst_n (ram_rstn),
    .ax_valid   (io_arw_valid),
    .ax_type    (io_arw_payload_write),
    .ax_id      (io_arw_payload_id),
    .ax_len     (io_arw_payload_len),
    .ax_size    (io_arw_payload_size),
    .ax_burst   (io_arw_payload_burst),
    .ax_addr    (io_arw_payload_addr),
    .ax_ready   (ax_ready),
    .w_valid    (io_w_valid),
    .w_id       (io_w_payload_id),
    .w_data     (io_w_payload_data),
    .w_strb     (io_w_payload_strb),
    .w_last     (io_w_payload_last),
    .w_ready    (io_w_ready),
    .b_ready    (io_b_ready),
    .b_id       (io_b_payload_id),
    .b_valid    (io_b_valid),
    .r_ready    (io_r_ready),
    .r_valid    (io_r_valid),
    .r_data     (io_r_payload_data),
    .r_id       (io_r_payload_id),
    .r_resp     (io_r_payload_resp),
    .r_last     (io_r_payload_last),
    .s_ax_type  (s_ax_type),
    .s_ax_id    (s_ax_id),
    .s_ax_len   (s_ax_len),
    .s_ax_size  (s_ax_size),
    .s_ax_burst (s_ax_burst),
    .s_ax_addr  (s_ax_addr),
    .s_ax_valid (s_ax_valid),
    .s_ax_ready (s_ax_ready),
    .s_w_valid  (s_w_valid),
    .s_w_data   (s_w_data),
    .s_w_strb   (s_w_strb),
    .s_w_last   (s_w_last),
    .s_w_ready  (s_w_ready),
    .s_b_ready  (s_b_ready),
    .s_b_id     (s_b_id),
    .s_b_valid  (s_b_valid),
    .s_b_resp   (s_b_resp),
    .s_r_ready  (s_r_ready),
    .s_r_valid  (s_r_valid),
    .s_r_data   (s_r_data),
    .s_r_id     (s_r_id),
    .s_r_resp   (s_r_resp),
    .s_r_last   (s_r_last),
    .local_ax_ready (io_arw_ready)
);
`IP_MODULE_NAME(hbram_user_if) # (
    .AXI_DBW  (AXI_DBW),
    .RAM_DBW  (RAM_DBW),
    .RAM_2DBW (RAM_DBW_TWO),
    .RAM_DMW  (RAM_DMW_TWO),
    .D_RATIO  (D_RATIO),
    .DUAL_RAM (DUAL_RAM)
) xhbram_user_if (
    .clk      (ram_clk),
    .rst_n    (ram_rstn),
    .ax_valid (s_ax_valid),
    .ax_type  (s_ax_type),
    .ax_id    (s_ax_id),
    .ax_len   (s_ax_len),
    .ax_size  (s_ax_size),
    .ax_burst (s_ax_burst),
    .ax_addr  (s_ax_addr),
    .ax_ready (s_ax_ready),
    .w_valid  (s_w_valid),
    .w_data   (s_w_data),
    .w_strb   (s_w_strb),
    .w_last   (s_w_last),
    .w_ready  (s_w_ready),
    .b_ready  (s_b_ready),
    .b_id     (s_b_id),
    .b_valid  (s_b_valid),
    .b_resp   (s_b_resp),
    .r_ready  (s_r_ready),
    .r_valid  (s_r_valid),
    .r_data   (s_r_data),
    .r_id     (s_r_id),
    .r_resp   (s_r_resp),
    .r_last   (s_r_last),
    .h_wrdy   (h_wrdy),
    .h_mrdy   (h_mrdy),
    .h_rdata  (h_rdata),
    .h_rdav   (h_rdav),
    .h_pause  (h_pause),
    .h_rwen   (h_rwen),
    .h_req    (h_req),
    .h_addr   (h_addr),
    .h_wdata  (h_wdata),
    .h_wdm    (h_wdm),
    .h_last   (h_last),
    .h_ctc    (h_ctc),
    .h_btype  (h_btype),
    .h_atype  (h_atype)
);
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(efx_bit_sync) (
    input   wire clk,
    input   wire rstn,
    input   wire din,
    output  wire dout
);
parameter STAGES = 2; 
parameter RSTVAL = 0; 
generate
    if (STAGES > 1) begin : syn_mflop
        reg [STAGES-1:0] sync_pipe;
        always @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                sync_pipe <= {(STAGES){(RSTVAL==0)? 1'b0 : 1'b1}};
            end else begin
                sync_pipe <= {sync_pipe[STAGES-2:0],din};
            end
        end
        assign dout = sync_pipe[STAGES-1];
    end else if (STAGES == 1) begin : syn_sflop
        reg sync_pipe;
        always @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                sync_pipe <= (RSTVAL==0)? 1'b0 : 1'b1;
            end else begin
                sync_pipe <= din;
            end
        end
        assign dout = sync_pipe;
    end else begin : syn_nflop
        assign dout = din;
    end
endgenerate
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(efx_axi_amux_top) #(
    parameter CTRL_DBW      = 8,
    parameter AXI_DBW       = 16,
    parameter AXI_AWR_DEPTH = 16,
    parameter AXI_W_DEPTH   = 256,
    parameter AXI_R_DEPTH   = 256,
    parameter AXI_SBW       = AXI_DBW / 8,
    parameter DPARTITION    = AXI_DBW / CTRL_DBW,
    parameter A2C_DBW       = AXI_DBW / DPARTITION,
    parameter A2C_SBW       = CTRL_DBW / 8,
    parameter EFF_AXI_R_DEPTH = AXI_R_DEPTH * DPARTITION,
    parameter DUAL_RAM = 1
) (
    input  wire                axi_clk,
    input  wire                axi_rst_n,
    input  wire                ctrl_clk,
    input  wire                ctrl_rst_n,
    input  wire                ax_valid,
    input  wire                ax_type,
    input  wire [7:0]          ax_id,
    input  wire [7:0]          ax_len,
    input  wire [2:0]          ax_size,
    input  wire [1:0]          ax_burst,
    input  wire [31:0]         ax_addr,
    output wire                ax_ready,
    input  wire [7:0]          w_id,
    input  wire                w_valid,
    input  wire [AXI_DBW-1:0]  w_data,
    input  wire [AXI_SBW-1:0]  w_strb,
    input  wire                w_last,
    output wire                w_ready,
    input  wire                b_ready,
    output wire [7:0]          b_id,
    output wire [1:0]          b_resp,
    output wire                b_valid,
    input  wire                r_ready,
    output wire                r_valid,
    output wire [AXI_DBW-1:0]  r_data,
    output wire [7:0]          r_id,
    output wire [1:0]          r_resp,
    output wire                r_last,
    output wire                s_ax_type,
    output wire [7:0]          s_ax_id,
    output wire [7:0]          s_ax_len,
    output wire [2:0]          s_ax_size,
    output wire [1:0]          s_ax_burst,
    output wire [31:0]         s_ax_addr,
    output wire                s_ax_valid,
    input  wire                s_ax_ready,
    output wire                s_w_valid,
    output wire [A2C_DBW-1:0]  s_w_data,
    output wire [A2C_SBW-1:0]  s_w_strb,
    output wire                s_w_last,
    input  wire                s_w_ready,
    input  wire [7:0]          s_b_id,
    input  wire [1:0]          s_b_resp,
    input  wire                s_b_valid,
    output wire                s_b_ready,
    input  wire                s_r_valid,
    input  wire [CTRL_DBW-1:0] s_r_data,
    input  wire [7:0]          s_r_id,
    input  wire [1:0]          s_r_resp,
    input  wire                s_r_last,
    output wire                s_r_ready,
    input  wire                local_ax_ready
);
localparam A_FIFO_WIDTH  = clog2(AXI_AWR_DEPTH);
localparam A_CH_WIDTH    = 1+8+8+3+2+32;
localparam W_CH_WIDTH    = AXI_DBW + AXI_SBW + DPARTITION;
localparam R_CH_WIDTH    = AXI_DBW + DPARTITION + (8 * DPARTITION);
localparam A2C_TOTALW    = W_CH_WIDTH / DPARTITION;
localparam WR_ASYM_RATIO = (DPARTITION == 16) ? 0 :
                           (DPARTITION == 8)  ? 1 :
                           (DPARTITION == 4)  ? 2 :
                           (DPARTITION == 2)  ? 3 : 4;
localparam RD_ASYM_RATIO = (DPARTITION == 16) ? 8 :
                           (DPARTITION == 8)  ? 7 :
                           (DPARTITION == 4)  ? 6 :
                           (DPARTITION == 2)  ? 5 : 4;
localparam DP_WIDTH      = clog2(DPARTITION);
wire                  rd_fifo_prog_full;
wire                  rd_addr_ch_fifo;
wire                  addr_fifo_empty;
wire                  addr_fifo_full;
wire                  rd_fifo_full;
wire                  rd_fifo_empty;
wire                  int_w_last;
wire                  w_data_valid;
wire                  s_w_valid_int;
wire [W_CH_WIDTH-1:0] wr_wdata_fifo;
wire                  wr_full;
wire [4:0]            wr_wlast_cntr_b2g;
wire [4:0]            wr_wlast_cntr_b2g_sync;
wire [4:0]            wr_wlast_cntr_g2b;
wire                  wr_resp_en;
wire                  rd_bfifo;
wire                  wlast_cont;
wire [4:0]            wlast_minus;
(* async_reg = "true" *) reg [4:0] rd_wlast_cntr_sync_1;
(* async_reg = "true" *) reg [4:0] rd_wlast_cntr_sync_2;
reg       s_b_valid_r;
reg [4:0] wr_wlast_cntr;
reg [4:0] rd_wlast_cntr;
reg [1:0] s_w_valid_r;
wire [4:0] rd_wlast_ctr_fifo_wire;
reg [4:0] rd_wlast_ctr_fifo_r;
wire rd_counter_fifo_empty;
wire rd_counter_valid;
assign rd_addr_ch_fifo = s_ax_ready & ~addr_fifo_empty & ~rd_fifo_prog_full;
assign s_w_valid_int   = s_w_ready  & (wr_wlast_cntr_g2b - rd_wlast_cntr > 0);
reg first_valid;
always @(posedge axi_clk or negedge axi_rst_n) begin
	 if (!axi_rst_n) begin
	 	 first_valid <= 0;
	 end else if (rd_counter_valid) begin
	 	 first_valid <= 1;
	 end
end
always @(posedge axi_clk or negedge axi_rst_n) begin
	 if (!axi_rst_n) begin
	 	 rd_wlast_ctr_fifo_r <= 0;
	 end
	 else if (~rd_counter_valid && ~first_valid) begin
	 	 rd_wlast_ctr_fifo_r <= 0;
	 end else begin
	 	 rd_wlast_ctr_fifo_r <= rd_wlast_ctr_fifo_wire;
	 end
end
wire rst_busy_wfifo;
wire rst_busy_wfifo_sync;
`IP_MODULE_NAME(efx_asyncreg)
# (.ASYNC_STAGE(2), .WIDTH(1), .ACTIVE_LOW(1)) rst_busy_sync
(.clk(axi_clk), .reset_n(axi_rst_n), .d_i(~rst_busy_wfifo), .d_o(rst_busy_wfifo_sync));
assign s_w_valid       = (s_w_valid_int & s_w_valid_r == 2'b00) | w_data_valid;
assign ax_ready        = ~addr_fifo_full;
assign s_ax_valid      = ~addr_fifo_empty & ~rd_fifo_prog_full;
assign wlast_minus     = wr_wlast_cntr - rd_wlast_ctr_fifo_r;
assign wlast_cont      = wlast_minus >= 'd14; 
assign w_ready         = ~wr_full & ~wlast_cont & rst_busy_wfifo_sync;
`IP_MODULE_NAME(efx_fifo_top) # (
    .FAMILY             ("TITANIUM"),
    .SYNC_CLK           (0),
    .BYPASS_RESET_SYNC  (0),
    .MODE               ("STANDARD"),
    .DEPTH              (AXI_AWR_DEPTH),
    .DATA_WIDTH         (A_CH_WIDTH),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (1),
    .OUTPUT_REG         (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (4)
) addr_fifo (
    .a_rst_i        (~axi_rst_n),
    .wr_clk_i       (axi_clk),
    .rd_clk_i       (ctrl_clk),
    .wr_en_i        (ax_valid & local_ax_ready),
    .rd_en_i        (rd_addr_ch_fifo),
    .wdata          ({ax_type,ax_id,ax_len,ax_size,ax_burst,ax_addr}),
    .full_o         (addr_fifo_full),
    .empty_o        (addr_fifo_empty),
    .almost_empty_o (),
    .rd_valid_o     (),
    .rdata          ({s_ax_type,s_ax_id,s_ax_len,s_ax_size,s_ax_burst,s_ax_addr})
);
genvar i;
generate
	for (i=0;i<DPARTITION;i=i+1) begin
		assign wr_wdata_fifo[(A2C_TOTALW*(DPARTITION-1-i))+:A2C_TOTALW] = {{DPARTITION{w_last}},w_strb[(A2C_SBW*i)+:A2C_SBW],w_data[(A2C_DBW*i)+:A2C_DBW]};
	end 
endgenerate
`IP_MODULE_NAME(efx_fifo_top) # (
    .FAMILY             ("TITANIUM"),
    .SYNC_CLK           (0),
    .BYPASS_RESET_SYNC  (0),
    .MODE               ("STANDARD"),
    .DEPTH              (AXI_W_DEPTH),
    .DATA_WIDTH         (W_CH_WIDTH),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (1),
    .OUTPUT_REG         (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (WR_ASYM_RATIO)
) wr_data_fifo (
    .a_rst_i            (~axi_rst_n),
    .wr_clk_i           (axi_clk),
    .rd_clk_i           (ctrl_clk),
    .wr_en_i            (w_valid & w_ready),
    .rst_busy			(rst_busy_wfifo),
    .rd_en_i            (s_w_valid_r[1]),
    .wdata              (wr_wdata_fifo),
    .full_o             (wr_full),
    .empty_o            (),
    .almost_empty_o     (),
    .rd_valid_o         (w_data_valid),
    .rdata              ({int_w_last,s_w_strb,s_w_data})
);
`IP_MODULE_NAME(efx_fifo_top) # (
    .FAMILY             ("TITANIUM"),
    .SYNC_CLK           (0),
    .BYPASS_RESET_SYNC  (0),
    .MODE               ("STANDARD"),
    .DEPTH              (16),
    .DATA_WIDTH         (5),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (1),
    .OUTPUT_REG         (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (4)
) rd_counter_fifo (
    .a_rst_i            (~axi_rst_n),
    .wr_clk_i           (ctrl_clk),
    .rd_clk_i           (axi_clk),
    .wr_en_i            (w_data_valid && s_w_last),
    .rd_en_i            (~rd_counter_fifo_empty),
    .wdata              (rd_wlast_cntr + 'd1),
    .full_o             (),
    .empty_o            (rd_counter_fifo_empty),
    .almost_empty_o     (),
    .rd_valid_o         (rd_counter_valid),
    .rdata              (rd_wlast_ctr_fifo_wire)
);
always @ (posedge axi_clk or negedge axi_rst_n) begin
    if (!axi_rst_n) begin
        wr_wlast_cntr <= 'd0;
    end
    else if (w_last && w_valid && w_ready) begin
        wr_wlast_cntr <= wr_wlast_cntr + 1'd1;
    end
end
reg [4:0] wr_wlast_cntr_b2g_r;
always @ (posedge axi_clk or negedge axi_rst_n) begin
    if (!axi_rst_n) begin
        wr_wlast_cntr_b2g_r <= 'h0;
    end
    else begin
        wr_wlast_cntr_b2g_r <= wr_wlast_cntr_b2g;
    end
end
`IP_MODULE_NAME(efx_fifo_bin2gray) # (.WIDTH(5)            ) wr2rd_bin2gray  (.bin_i(wr_wlast_cntr), .gray_o(wr_wlast_cntr_b2g));
`IP_MODULE_NAME(efx_asyncreg) 	  # (.ASYNC_STAGE(2), .WIDTH(5), .ACTIVE_LOW(1)) wr2rd_addr_sync (.clk(ctrl_clk), .reset_n(ctrl_rst_n), .d_i(wr_wlast_cntr_b2g_r), .d_o(wr_wlast_cntr_b2g_sync));
`IP_MODULE_NAME(efx_fifo_gray2bin) # (.WIDTH(5)            ) wr2rd_gray2bin  (.gray_i(wr_wlast_cntr_b2g_sync), .bin_o(wr_wlast_cntr_g2b));
always @ (posedge ctrl_clk or negedge ctrl_rst_n) begin
    if (!ctrl_rst_n) begin
        rd_wlast_cntr <= 'd0;
    end
    else if (w_data_valid && s_w_last) begin
        rd_wlast_cntr <= rd_wlast_cntr + 1'd1;
    end
end
always @ (posedge ctrl_clk or negedge ctrl_rst_n) begin
    if (!ctrl_rst_n) begin
        s_w_valid_r <= 'd0;
    end
    else if (~s_w_valid_int && s_w_valid_r[1]) begin
        s_w_valid_r <= 'd0;
    end
    else if (s_w_valid_int) begin
        s_w_valid_r <= {s_w_valid_r[0],s_w_valid_int};
    end
end
generate
    if (AXI_DBW == CTRL_DBW) begin 
        wire dpartition_count;
        assign s_w_last        = int_w_last & (&dpartition_count);
        assign dpartition_count = 1'b1;
    end
    else begin
	reg  [DP_WIDTH-1:0] dpartition_count;
	assign s_w_last        = int_w_last & (&dpartition_count);
		always @ (posedge ctrl_clk or negedge ctrl_rst_n) begin
			if (!ctrl_rst_n) begin
				dpartition_count <= 'd0;
			end
			else if (s_b_valid_r) begin 
				dpartition_count <= 'd0;
			end
			else if (w_data_valid) begin 
				dpartition_count <= dpartition_count + 1'b1;
			end
		end
    end
endgenerate
assign wr_resp_en = s_b_valid | s_b_valid_r;
always @ (posedge ctrl_clk or negedge ctrl_rst_n) begin
    if (!ctrl_rst_n) begin
        s_b_valid_r <= 'd0;
    end
    else begin
        s_b_valid_r <= s_b_valid;
    end
end
wire [7:0] b_id_w;
wire b_valid_w;
wire b_fifo_valid;
assign b_id = (b_fifo_valid)? b_id_w:8'b0;
assign b_valid = (b_fifo_valid)? b_valid_w:1'b0;
`IP_MODULE_NAME(efx_fifo_top) # (
    .FAMILY             ("TITANIUM"),
    .SYNC_CLK           (0),
    .BYPASS_RESET_SYNC  (0),
    .MODE               ("STANDARD"),
    .DEPTH              (4),
    .DATA_WIDTH         (11),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (1),
    .OUTPUT_REG         (0),
    .PROGRAMMABLE_FULL  ("NONE"),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (4)
) wr_response_fifo (
    .a_rst_i        (~axi_rst_n),
    .wr_clk_i       (ctrl_clk),
    .rd_clk_i       (axi_clk),
    .wr_en_i        (wr_resp_en),
    .rd_en_i        (~rd_bfifo),
    .wdata          ({s_b_resp,s_b_id,s_b_valid}),
    .full_o         (),
    .empty_o        (rd_bfifo),
    .almost_empty_o (),
    .rd_valid_o     (b_fifo_valid),
    .rdata          ({b_resp,b_id_w,b_valid_w})
);
wire [R_CH_WIDTH-1:0] rd_fifo_rdata;
wire [DPARTITION-1:0] r_last_int;
wire                  rd_rfifo;
wire                  r_valid_int;
reg                   r_valid_r;
always @ (posedge axi_clk or negedge axi_rst_n) begin
    if (~axi_rst_n) begin
        r_valid_r <= 1'b0;
    end
    else if (r_valid && ~r_ready) begin
        r_valid_r <= 1'b1;
    end
    else if (r_valid && r_ready) begin
        r_valid_r <= 1'b0;
    end
end
assign r_last   = |r_last_int & r_valid;
assign r_id     = (r_valid_int)? rd_fifo_rdata[CTRL_DBW+8:CTRL_DBW+1]: 8'b0;
assign r_resp   = 2'd0;
assign r_valid  = r_valid_int | r_valid_r;
assign rd_rfifo = r_ready & ~rd_fifo_empty;
assign s_r_ready = ~rd_fifo_full;
genvar j;
generate
    for (j=0;j<DPARTITION;j=j+1) begin
        assign r_data[(CTRL_DBW*(DPARTITION-1-j))+:CTRL_DBW] = (r_valid_int)? rd_fifo_rdata[(CTRL_DBW+1+8)*j+:CTRL_DBW]:{CTRL_DBW{1'b0}};
        assign r_last_int[j]                                 = rd_fifo_rdata[((CTRL_DBW+1+8)*j)+CTRL_DBW];
    end
endgenerate
`IP_MODULE_NAME(efx_fifo_top) #(
	.FAMILY 			("TITANIUM"),
    .SYNC_CLK           (0),
    .OUTPUT_REG         (0),
    .MODE               ("STANDARD"),
    .PIPELINE_REG       (1),
    .OPTIONAL_FLAGS     (1),
    .PROGRAMMABLE_FULL  ("STATIC_SINGLE"),
    .PROG_FULL_ASSERT   (EFF_AXI_R_DEPTH/2),
    .PROGRAMMABLE_EMPTY ("NONE"),
    .ASYM_WIDTH_RATIO   (RD_ASYM_RATIO),
    .DATA_WIDTH         (CTRL_DBW+1+8),
    .DEPTH              (EFF_AXI_R_DEPTH)
) rd_data_fifo (
    .a_rst_i        (~axi_rst_n),
    .wr_clk_i       (ctrl_clk),
    .rd_clk_i       (axi_clk),
    .wr_en_i        (s_r_valid),
    .wdata          ({s_r_id,s_r_last,s_r_data}),
    .rd_en_i        (rd_rfifo), 
    .rdata          (rd_fifo_rdata),
    .rd_valid_o     (r_valid_int),
    .full_o         (rd_fifo_full),
    .prog_full_o    (rd_fifo_prog_full),
    .empty_o        (rd_fifo_empty)
);
function integer clog2;
input integer value;
begin
    value = value-1;
    for (clog2=0; value>0; clog2=clog2+1)
        value = value>>1;
end
endfunction
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end





// IP Decryptor begin

//##START PROTECT##
module `IP_MODULE_NAME(efx_datasync) #(
    parameter STAGE = 32,
    parameter WIDTH = 4
) (
    input  wire             clk_i,
    input  wire             rst_n,
    input  wire [WIDTH-1:0] data_in,
    output wire [WIDTH-1:0] data_out
);
(* async_reg = "true" *) reg [WIDTH-1:0] pipe_reg [STAGE-1:0];
integer i;
assign data_out = pipe_reg[STAGE-1];
always @(posedge clk_i) begin
    for (i=STAGE-1; i>0; i = i - 1) begin
        pipe_reg[i] <= pipe_reg[i-1];
    end
    pipe_reg[0] <= data_in;
end
endmodule
//##END PROTECT##
`endprotect


// IP Decryptor end


`undef IP_UUID
`undef IP_NAME_CONCAT
`undef IP_MODULE_NAME
